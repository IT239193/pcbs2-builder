
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PCBS2 Ultimate Pro Builder - Live Calculator</title>
    <style>
        :root {
            --bg-dark: #0f0f1e;
            --bg-panel: #1a1a2e;
            --accent: #3498db;
            --accent-hover: #2980b9;
            --highlight: #e67e22; 
            --text-main: #ecf0f1;
            --text-muted: #95a5a6;
            --border: rgba(52, 152, 219, 0.3);

            --price-red: #ff4757;
            --watt-lime: #d4e157;
            --score-blue: #00d2ff;
            --success: #2ecc71;
            --error: #e74c3c;
            --warning: #f1c40f;

            /* Brand Colors */
            --brand-amd: #d35400;
            --brand-intel: #00d2ff;
            --brand-intel-gpu: #0047AB;
            --brand-nvidia: #76b900;
            --brand-ram: #e0b0ff;
            --brand-aux: #e0b0ff;
            
            /* Dark Grey for Generic/Case */
            --brand-generic: #2c3e50; 
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0b0c15 0%, #151621 100%);
            color: var(--text-main);
            min-height: 100vh;
            padding: 20px;
            font-size: 14px;
            overflow-y: scroll;
            zoom: 90%;
        }

        .container { max-width: 1800px; margin: 0 auto; padding-bottom: 100px; }

        /* Loading Overlay */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 30, 0.95);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
            transition: opacity 0.5s ease;
        }
        
        .spinner {
            width: 60px;
            height: 60px;
            border: 6px solid rgba(52, 152, 219, 0.2);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        #loadingText {
            font-size: 1.5em;
            color: var(--accent);
            font-weight: bold;
            letter-spacing: 1px;
        }

        /* Header */
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            border: 1px solid var(--border);
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.1);
            position: relative;
        }

        header h1 {
            font-size: 2.5em;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .header-subtitle {
            font-size: 1.1em;
            color: var(--text-muted);
            margin-top: 5px;
            font-weight: 500;
        }

        /* Perf Warning */
        #perfWarning {
            background: rgba(231, 76, 60, 0.15);
            border: 1px solid var(--error);
            color: var(--text-main);
            padding: 10px 15px;
            margin: 15px auto 0 auto;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            font-weight: 500;
            max-width: 800px;
            position: relative;
        }
        #perfWarning.hidden { display: none !important; }
        #perfWarning span { font-weight: bold; color: var(--error); }
        .close-warning {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5em;
            cursor: pointer;
            color: var(--text-muted);
        }
        .close-warning:hover { color: white; }

        /* Controls */
        .controls-wrapper {
            background: var(--bg-panel);
            padding: 30px;
            border-radius: 12px;
            border: 1px solid var(--border);
            margin-bottom: 30px;
            opacity: 0.6;
            pointer-events: none;
            transition: 0.3s;
        }
        .controls-wrapper.active { opacity: 1; pointer-events: all; }

        .section-header {
            font-size: 1.3em;
            color: var(--accent);
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Benchmark Toggle */
        .benchmark-toggle {
            display: flex;
            gap: 0;
            margin-bottom: 25px;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid var(--border);
            width: fit-content;
        }
        .mode-btn {
            padding: 12px 30px;
            font-size: 1.1em;
            font-weight: bold;
            background: #0f0f1e;
            color: var(--text-muted);
            border: none;
            cursor: pointer;
            transition: 0.2s;
            border-right: 1px solid var(--border);
        }
        .mode-btn:last-child { border-right: none; }
        .mode-btn:hover { background: rgba(230, 126, 34, 0.2); color: white; }
        
        .mode-btn.active { 
            background: var(--highlight); 
            color: white; 
            border-color: var(--highlight);
        }

        /* Input Grid */
        .input-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }
        .ram-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }
        
        .input-group { display: flex; flex-direction: column; }
        .input-group label {
            margin-bottom: 8px;
            color: var(--text-muted);
            font-size: 0.9em;
            font-weight: 600;
        }
        .input-group input, .input-group select {
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border);
            color: white;
            padding: 12px;
            border-radius: 6px;
            font-size: 1em;
        }
        .input-group input:focus, .input-group select:focus {
            border-color: var(--accent);
            outline: none;
            background: rgba(0,0,0,0.5);
        }

        /* Checkboxes */
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0,0,0,0.2);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid var(--border);
            height: 100%;
        }
        .checkbox-container input {
            width: 20px;
            height: 20px;
            accent-color: var(--accent);
            cursor: pointer;
        }
        .checkbox-container label {
            margin: 0;
            cursor: pointer;
            font-weight: 600;
            font-size: 1em;
        }

        /* Multi-Select Dropdowns */
        .multi-select-container { position: relative; width: 100%; }
        .multi-select-display {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
            padding: 12px;
            border-radius: 6px;
            color: #fff;
            font-size: 1.0em;
            cursor: pointer;
            min-height: 45px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            user-select: none;
        }
        .multi-select-display:hover { border-color: var(--accent); }
        .multi-select-display:after {
            content: 'â–¼';
            position: absolute;
            right: 12px;
            color: var(--text-muted);
            font-size: 0.8em;
        }

        .multi-dropdown {
            position: absolute;
            top: 105%;
            left: 0;
            width: 100%;
            background: #1e1e2f;
            border: 1px solid var(--border);
            border-radius: 6px;
            z-index: 1000;
            display: none;
            box-shadow: 0 10px 25px rgba(0,0,0,0.8);
            overflow: hidden;
            flex-direction: column;
        }
        .multi-dropdown.show { display: flex; max-height: 500px; }

        /* Quick Filter Bar */
        .quick-filter-bar {
            padding: 8px;
            background: #151525;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .filter-btn {
            padding: 5px 10px;
            font-size: 0.85em;
            background: transparent;
            border: 1px solid #555;
            color: #ccc;
            border-radius: 4px;
            cursor: pointer;
            transition: 0.2s;
            font-weight: 600;
        }
        .filter-btn:hover { color: #fff; }

        .btn-clear { border-color: var(--brand-generic); color: var(--error); }
        .btn-clear:hover { background: var(--brand-generic); color: white; }

        .btn-amd { border-color: var(--brand-amd); color: var(--brand-amd); }
        .btn-amd:hover { background: var(--brand-amd); color: white; }

        .btn-intel { border-color: var(--brand-intel); color: var(--brand-intel); }
        .btn-intel:hover { background: var(--brand-intel); color: white; }

        .btn-nvidia { border-color: var(--brand-nvidia); color: var(--brand-nvidia); }
        .btn-nvidia:hover { background: var(--brand-nvidia); color: white; }

        /* New Size Buttons */
        .btn-size-filter {
            background: rgba(52, 152, 219, 0.1);
            border-color: var(--accent);
            color: var(--text-muted);
        }
        .btn-size-filter:hover {
            background: var(--accent);
            color: white;
        }

        .dropdown-search-container {
            padding: 8px;
            background: #151525;
            border-bottom: 1px solid var(--border);
        }
        .dropdown-search {
            width: 100%;
            padding: 8px;
            font-size: 0.9em;
            border: 1px solid #444;
            background: #0f0f1e;
            color: white;
            border-radius: 4px;
        }
        .dropdown-list-container {
            overflow-y: auto;
            max-height: 300px;
        }
        .multi-option {
            padding: 8px 12px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            cursor: pointer;
            display: flex;
            align-items: center;
            transition: 0.1s;
            user-select: none;
            justify-content: space-between;
        }
        .multi-option:hover { background: rgba(52, 152, 219, 0.2); }
        .multi-option.selected { background: rgba(52, 152, 219, 0.4); }
        .multi-option.selected .cb-custom {
            background: var(--accent);
            border-color: var(--accent);
        }
        .multi-option.selected .cb-custom:after {
            content: 'âœ“';
            font-size: 12px;
            color: white;
            font-weight: bold;
        }
        .option-left { display: flex; align-items: center; flex: 1; overflow: hidden; }

        .cb-custom {
            width: 16px;
            height: 16px;
            border: 1px solid var(--text-muted);
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            flex-shrink: 0;
        }

        /* Quantity Controls */
        .qty-controls {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            padding: 2px;
        }
        .qty-btn {
            background: #444;
            border: none;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 2px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        .qty-btn:hover { background: var(--accent); }
        .qty-val {
            font-weight: bold;
            color: var(--score-blue);
            min-width: 20px;
            text-align: center;
        }

        /* Generate Button */
        .btn-generate {
            width: 100%;
            padding: 18px;
            font-size: 1.5em;
            font-weight: 800;
            background: linear-gradient(90deg, #2980b9, var(--accent));
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 20px;
        }
        .btn-generate:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(52, 152, 219, 0.3);
        }

        /* Results Meta Bar */
        .results-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-panel);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border);
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
            position: relative;
        }
        .result-count {
            font-size: 1.4em;
            font-weight: bold;
            color: var(--text-main);
        }
        .sort-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .sort-select {
            padding: 15px 20px;
            background: #0f0f1e;
            border: 1px solid var(--accent);
            color: white;
            border-radius: 4px;
            font-weight: bold;
            font-size: 1.1em;
            min-width: 320px;
            height: 60px;
            cursor: pointer;
        }

        .min-score-container {
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(52, 152, 219, 0.15);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid var(--border);
            height: 60px;
            position: relative;
        }
        .min-score-label {
            font-size: 1.2em;
            font-weight: bold;
            color: #4169E1;
            white-space: nowrap;
        }
        #minScoreInput {
            width: 150px;
            font-size: 1.2em;
            padding: 10px;
            height: 40px;
            background: #0f0f1e;
            border: 1px solid var(--accent);
            font-weight: bold;
            color: #fff;
            border-radius: 4px;
        }

        .score-range-text {
            color: #95a5a6;
            font-weight: 500;
            font-size: 1.4em;
            margin-left: 20px;
            white-space: nowrap;
            display: inline-block;
        }

        /* Build Cards */
        .build-card {
            background: var(--bg-panel);
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
            animation: slideIn 0.4s ease-out forwards;
            opacity: 0;
            border-left: 6px solid #444;
        }
        .build-card:hover {
            border-color: var(--accent);
            box-shadow: 0 5px 25px rgba(0,0,0,0.5);
        }

        .card-header {
            background: rgba(0,0,0,0.3);
            padding: 15px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .score-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .build-number {
            color: #666;
            font-size: 0.9em;
            width: 40px;
        }
        .score-box {
            font-size: 2.2em;
            font-weight: 900;
            color: #fff;
            line-height: 1;
        }
        .diff-box {
            font-size: 1.4em;
            font-weight: bold;
            margin-left: 10px;
        }
        .diff-pos { color: var(--success); }
        .diff-neg { color: var(--error); }

       .header-stats {
            text-align: right;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        
        .stats-row {
            display: flex;
            align-items: center;
            gap: 15px; 
        }

        .price-box {
            font-size: 1.8em;
            color: var(--price-red);
            font-weight: bold;
        }

        .watts-box {
            font-size: 1.8em;
            color: var(--watt-lime);
            font-weight: 800;
            margin-top: 0; 
        }

        .level-box {
            font-size: 0.95em;
            color: #cd853f;
            font-weight: bold;
            margin-top: 5px;
        }


        .card-body {
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        /* Part Rows */
        .part-row {
            display: flex;
            flex-direction: column;
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
            padding: 12px;
            border-left: 4px solid #555;
            position: relative;
            --row-color: #fff;
        }

        .part-row.brand-amd { border-left-color: var(--brand-amd); --row-color: var(--brand-amd); }
        .part-row.brand-intel { border-left-color: var(--brand-intel); --row-color: var(--brand-intel); }
        .part-row.brand-intel-gpu { border-left-color: var(--brand-intel-gpu); --row-color: var(--brand-intel-gpu); }
        .part-row.brand-nvidia { border-left-color: var(--brand-nvidia); --row-color: var(--brand-nvidia); }
        .part-row.brand-ram { border-left-color: var(--brand-ram); --row-color: var(--brand-ram); }
        .part-row.brand-aux { border-left-color: var(--brand-aux); --row-color: var(--brand-aux); }
        
        .part-row.brand-generic {
            background: var(--brand-generic);
            border-left-color: #7f8c8d;
        }
        .part-row.brand-generic .part-label,
        .part-row.brand-generic .part-name,
        .part-row.brand-generic .part-specs,
        .part-row.brand-generic .part-price {
            color: #ecf0f1 !important;
        }

        .part-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .part-label {
            font-size: 0.85em;
            text-transform: uppercase;
            color: var(--text-muted);
            font-weight: bold;
        }
        .part-price {
            color: var(--price-red);
            font-weight: 600;
            font-size: 1.25em;
        }
        .part-name {
            font-size: 1.35em;
            font-weight: 800;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: #fff; 
        }

        .part-row.text-colored .part-label,
        .part-row.text-colored .part-price,
        .part-row.text-colored .part-name,
        .part-row.text-colored .part-specs {
            color: var(--row-color) !important;
        }

        .part-specs {
            font-size: 1.25em;
            font-weight: 600;
            line-height: 1.4;
            margin-top: 5px;
            padding: 2px 0;
            color: #bdc3c7;
        }

        /* Interactive Parts */
        .part-row.interactive {
            cursor: pointer;
            transition: 0.2s;
            border: 1px dashed rgba(255,255,255,0.1);
        }
        .part-row.interactive:hover {
            background: rgba(52, 152, 219, 0.1);
            border-color: var(--accent);
        }

        .btn-change {
            position: absolute;
            right: 10px;
            top: 10px;
            background: var(--accent);
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
            opacity: 0;
            transition: 0.2s;
            cursor: pointer;
        }
        .part-row.interactive:hover .btn-change { opacity: 1; }

        /* Popup Overlay */
        #popupOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 9998;
            display: none;
            backdrop-filter: blur(5px);
        }
        #popupContainer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 95%;
            max-width: 1200px;
            height: 90vh;
            background: #151525;
            border: 2px solid var(--accent);
            border-radius: 12px;
            z-index: 9999;
            display: none;
            flex-direction: column;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        .popup-header {
            padding: 20px;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .popup-title {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--text-main);
        }
        .popup-close {
            font-size: 2em;
            cursor: pointer;
            color: var(--text-muted);
            line-height: 0.5;
        }
        .popup-close:hover { color: var(--error); }

        .popup-filters {
            padding: 15px;
            display: flex;
            gap: 15px;
            background: #0f0f1e;
            border-bottom: 1px solid var(--border);
            align-items: center;
            flex-wrap: wrap;
        }

        #popupSearch {
            padding: 12px 15px;
            background: #0b0c15;
            border: 1px solid var(--accent);
            color: white;
            border-radius: 4px;
            font-size: 1.1em;
            width: 300px;
            margin-left: 20px;
        }

        #popupSort {
            width: 250px;
            padding: 12px 15px;
            height: 50px;
            font-size: 1.1em;
            background: #0f0f1e;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
        }

        .popup-body {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        .popup-table {
            width: 100%;
            border-collapse: collapse;
        }
        .popup-table th {
            text-align: left;
            padding: 15px;
            background: #202030;
            color: #ccc;
            position: sticky;
            top: 0;
            z-index: 2;
        }
        .popup-table td {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            color: #ddd;
            vertical-align: middle;
        }
        .popup-table tr:hover { background: rgba(255,255,255,0.05); }

        .price-red-cell {
            color: var(--price-red) !important;
            font-weight: bold;
            font-size: 1.1em;
        }

        .val-pos {
            color: var(--success);
            font-weight: bold;
        }
        .val-neg {
            color: var(--error);
            font-weight: bold;
        }
        
        .btn-select-part {
            background: var(--success);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
        }
        .btn-select-part.selected {
            background: var(--error);
            content: "REMOVE";
        }
        .btn-select-part:hover {
            transform: scale(1.05);
        }
        .btn-select-part:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 40px;
            padding: 20px;
            display: none;
            align-items: center;
        }
        .page-btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .page-btn:disabled {
            background: #444;
            cursor: not-allowed;
            opacity: 0.5;
        }
        .page-info {
            color: white;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 4px;
        }
        .page-jump-input {
            width: 80px;
            padding: 5px;
            background: #0f0f1e;
            border: 1px solid var(--accent);
            color: white;
            text-align: center;
            font-size: 1.1em;
            border-radius: 4px;
        }

        /* Sadece RAM Models dropdown kutusunun yazÄ±sÄ±nÄ± bÃ¼yÃ¼tÃ¼r */
        #multiRam .multi-select-display {
            font-size: 1.4em; 
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 600px) {
            .card-body { grid-template-columns: 1fr; }
            .card-header { flex-direction: column; gap: 15px; }
            .header-stats { text-align: left; align-items: flex-start; }
            .results-meta { flex-direction: column; align-items: flex-start; }
        }
    </style>
</head>
<body>

<!-- Loading Screen -->
<div id="loadingOverlay">
    <div class="spinner"></div>
    <div id="loadingText">Connecting to Database...</div>
</div>

<!-- Popup Overlay for Part Swapping -->
<div id="popupOverlay" onclick="closePopup()"></div>
<div id="popupContainer">
    <div class="popup-header">
        <div class="popup-title" id="popupTitle">Select Replacement Part</div>
        <div class="popup-close" onclick="closePopup()">&times;</div>
    </div>
    <div class="popup-filters">
        <div class="checkbox-container">
            <input type="checkbox" id="popupFit" checked onchange="refreshPopup()">
            <label for="popupFit">Show Only Fitting Parts</label>
        </div>
        
        <input type="text" id="popupSearch" placeholder="ðŸ” Search part by name..." oninput="refreshPopup()">

        <div style="flex:1;"></div>
        <label>Sort By:</label>
        <select id="popupSort" onchange="refreshPopup()">
            <option value="price_asc">Lowest Price</option>
            <option value="price_desc">Highest Price</option>
            <option value="perf_desc">Highest Performance</option>
            <option value="val_desc">Most Overperforming (Best Value)</option>
            <option value="val_asc">Most Underperforming (Worst Value)</option>
        </select>
    </div>
    <div class="popup-body">
        <table class="popup-table">
            <thead>
                <tr>
                    <th style="width:100px;">Action</th>
                    <th>Part Name</th>
                    <th>Specs</th>
                    <th>Price</th>
                    <th>Cost Diff</th>
                </tr>
            </thead>
            <tbody id="popupTableBody"></tbody>
        </table>
    </div>
</div>

<div class="container">
    <header>
        <h1>PCBS2 Ultimate Builder</h1>
        <div class="header-subtitle">contact me on discord for bug reports @timmy2131_</div>
        
        <!-- Warning Message Moved Here -->
        <div id="perfWarning" class="hidden">
            <span>âš  PERFORMANCE WARNING:</span> 
            If you don't specify preferred RAM brand, size, frequency, or other component filters, the generated results pool will be massive, causing slow performance and potential browser freezing. Please refine your selection.
            <div class="close-warning" onclick="dismissWarning()">&times;</div>
        </div>
    </header>

    <div class="controls-wrapper" id="controls">
        <div class="section-header">1. Benchmarking & Goals</div>
        <div class="benchmark-toggle">
            <button id="btnTS" class="mode-btn active" onclick="setMode('TS')">Time Spy (Standard)</button>
            <button id="btnTSX" class="mode-btn" onclick="setMode('TSX')">Time Spy Extreme (4K)</button>
        </div>

        <div class="input-grid">
            <div class="input-group">
                <label>Budget ($)</label>
                <input type="text" id="budget" value="3,500">
            </div>
            <div class="input-group">
                <label>Target 3DMark Score</label>
                <input type="text" id="targetScore" value="20,000">
            </div>
            <div class="input-group">
                <label>GPU Count</label>
                <!-- NEW: Multi-Select for GPU Count -->
                <div id="multiGpuCount" class="multi-select-container">
                    <div class="multi-select-display" onclick="toggleDropdown('gpuCountDropdown')">Any</div>
                    <div id="gpuCountDropdown" class="multi-dropdown">
                        <div class="quick-filter-bar">
                            <button class="filter-btn btn-clear" onclick="clearFilter('gpuCount')">Clear</button>
                        </div>
                        <div class="dropdown-list-container" id="gpuCountListContainer"></div>
                    </div>
                </div>
            </div>
            <div class="input-group">
                <label>Career Level</label>
                <input type="number" id="level" value="30" min="1" oninput="refreshDropdowns()">
            </div>
            <div class="input-group">
                <label>Max Results Pool (if you decrease it will be faster but show less results)</label>
                <input type="text" id="resLimit" value="4,000,000">
            </div>
            <div class="input-group">
                <label>Results Per Page</label>
                <input type="number" id="resultsPerPage" value="100" min="1" max="1000">
            </div>
        </div>

        <div class="section-header">2. RAM Configuration</div>
        <div class="ram-grid">
            <div class="input-group">
                <label>Include RAM</label>
                <div style="display:flex; gap:10px;">
                    <div class="checkbox-container" style="flex:1;">
                        <input type="checkbox" id="incRam" checked>
                        <label for="incRam">Suggest RAM</label>
                    </div>
                    <!-- NEW: RAM Performance Mode Checkbox -->
                    <div class="checkbox-container" style="flex:1;">
                        <input type="checkbox" id="ramPerfMode" checked>
                        <label for="ramPerfMode">RAM Perf Mode</label>
                    </div>
                </div>
            </div>
            <div class="input-group">
                <label>Stick Count</label>
                <select id="ramSticks">
                    <option value="0" selected>Any</option>
                    <option value="1">1 Stick</option>
                    <option value="2">2 Sticks</option>
                    <option value="4">4 Sticks</option>
                </select>
            </div>
            
            <!-- CHANGED: Reverted to Multi-Select Dropdown for Stick Size -->
            <div class="input-group">
                <label>Ram Stick Size</label>
                <div id="multiRamSize" class="multi-select-container">
                    <div class="multi-select-display" onclick="toggleDropdown('ramSizeDropdown')">Any</div>
                    <div id="ramSizeDropdown" class="multi-dropdown">
                        <div class="quick-filter-bar">
                            <button class="filter-btn btn-clear" onclick="clearFilter('ramSizes')">Clear</button>
                        </div>
                        <div class="dropdown-list-container" id="ramSizeListContainer"></div>
                    </div>
                </div>
            </div>

            <!-- NEW: Target RAM Capacity Input -->
            <div class="input-group">
                <label>Target Total Capacity</label>
                <input type="number" id="targetTotalRam" placeholder="e.g. 128">
            </div>

            <!-- Filter by Manufacturer -->
            <div class="input-group">
                <label>RAM Manufacturer</label>
                <div id="multiRamMfgr" class="multi-select-container">
                    <div class="multi-select-display" onclick="toggleDropdown('ramMfgrDropdown')">Any</div>
                    <div id="ramMfgrDropdown" class="multi-dropdown">
                        <div class="quick-filter-bar">
                            <button class="filter-btn btn-clear" onclick="clearFilter('ramMfgrs')">Clear</button>
                        </div>
                        <div class="dropdown-list-container" id="ramMfgrListContainer"></div>
                    </div>
                </div>
            </div>

            <!-- Filter by Frequency -->
            <div class="input-group">
                <label>RAM Frequency</label>
                <div id="multiRamFreq" class="multi-select-container">
                    <div class="multi-select-display" onclick="toggleDropdown('ramFreqDropdown')">Any</div>
                    <div id="ramFreqDropdown" class="multi-dropdown">
                        <div class="quick-filter-bar">
                            <button class="filter-btn btn-clear" onclick="clearFilter('ramFreqs')">Clear</button>
                        </div>
                        <div class="dropdown-list-container" id="ramFreqListContainer"></div>
                    </div>
                </div>
            </div>

            <div class="input-group" style="grid-column: 1 / -1;">
                <label>Specific RAM Model(s)</label>
                <div id="multiRam" class="multi-select-container">
                    <div class="multi-select-display" onclick="toggleDropdown('ramDropdown')">Any</div>
                    <div id="ramDropdown" class="multi-dropdown">
                        <div class="quick-filter-bar">
                            <button class="filter-btn btn-clear" onclick="clearFilter('ramNames')">Clear</button>
                        </div>
                        <div class="dropdown-search-container">
                            <input type="text" class="dropdown-search" placeholder="Filter RAM..." oninput="filterDropdownList(this)">
                        </div>
                        <div class="dropdown-list-container" id="ramListContainer"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="section-header">3. Additional Components</div>
        <div class="input-grid">
            <div class="checkbox-container">
                <input type="checkbox" id="incMobo" checked> 
                <label for="incMobo">Motherboard</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="incCase" checked>
                <label for="incCase">Case</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="incCooler">
                <label for="incCooler">CPU Cooler</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="incPsu" checked>
                <label for="incPsu">PSU</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="incFans"> 
                <label for="incFans">Case Fans (x1)</label>
            </div>
            <div class="checkbox-container">
                <input type="checkbox" id="incStorage"> 
                <label for="incStorage">Include Storage</label>
            </div>
        </div>
        
        <div class="section-header">4. Component Filters</div>
        <div class="input-grid">
            <!-- CPU Socket Multi-Select -->
            <div class="input-group">
                <label>CPU Socket (Shift/Ctrl Click)</label>
                <div id="multiSocket" class="multi-select-container">
                    <div class="multi-select-display" onclick="toggleDropdown('socketDropdown')">Any</div>
                    <div id="socketDropdown" class="multi-dropdown">
                        <div class="quick-filter-bar">
                            <button class="filter-btn btn-clear" onclick="clearFilter('socket')">Clear</button>
                            <button class="filter-btn btn-amd" onclick="applyQuickFilter('socket', 'AMD')">Add AMD</button>
                            <button class="filter-btn btn-intel" onclick="applyQuickFilter('socket', 'Intel')">Add Intel</button>
                        </div>
                        <div class="dropdown-list-container" id="socketListContainer"></div>
                    </div>
                </div>
            </div>

            <!-- Specific CPU Multi-Select -->
            <div class="input-group">
                <label>Specific CPU Model(s)</label>
                <div id="multiCpu" class="multi-select-container">
                    <div class="multi-select-display" onclick="toggleDropdown('cpuDropdown')">Any</div>
                    <div id="cpuDropdown" class="multi-dropdown">
                        <div class="quick-filter-bar">
                            <button class="filter-btn btn-clear" onclick="clearFilter('cpuNames')">Clear</button>
                            <button class="filter-btn btn-amd" onclick="applyQuickFilter('cpuNames', 'AMD')">Add AMD</button>
                            <button class="filter-btn btn-intel" onclick="applyQuickFilter('cpuNames', 'Intel')">Add Intel</button>
                        </div>
                        <div class="dropdown-search-container">
                            <input type="text" class="dropdown-search" placeholder="Filter CPUs..." oninput="filterDropdownList(this)">
                        </div>
                        <div class="dropdown-list-container" id="cpuListContainer"></div>
                    </div>
                </div>
            </div>

            <!-- Specific GPU Multi-Select -->
            <div class="input-group">
                <label>Specific GPU Model(s)</label>
                <div id="multiGpu" class="multi-select-container">
                    <div class="multi-select-display" onclick="toggleDropdown('gpuDropdown')">Any</div>
                    <div id="gpuDropdown" class="multi-dropdown">
                        <div class="quick-filter-bar">
                            <button class="filter-btn btn-clear" onclick="clearFilter('gpuNames')">Clear</button>
                            <button class="filter-btn btn-nvidia" onclick="applyQuickFilter('gpuNames', 'NVIDIA')">Add NVIDIA</button>
                            <button class="filter-btn btn-amd" onclick="applyQuickFilter('gpuNames', 'AMD')">Add AMD</button>
                            <button class="filter-btn btn-intel" onclick="applyQuickFilter('gpuNames', 'Intel')">Add Intel</button>
                        </div>
                        <div class="dropdown-search-container">
                            <input type="text" class="dropdown-search" placeholder="Filter GPUs..." oninput="filterDropdownList(this)">
                        </div>
                        <div class="dropdown-list-container" id="gpuListContainer"></div>
                    </div>
                </div>
            </div>

            <!-- VRAM Multi-Select -->
            <div class="input-group">
                <label>Target VRAM</label>
                <div id="multiVram" class="multi-select-container">
                    <div class="multi-select-display" onclick="toggleDropdown('vramDropdown')">Any</div>
                    <div id="vramDropdown" class="multi-dropdown">
                        <div class="quick-filter-bar">
                            <button class="filter-btn btn-clear" onclick="clearFilter('vram')">Clear Selection</button>
                        </div>
                        <div class="dropdown-list-container" id="vramListContainer"></div>
                    </div>
                </div>
            </div>

            <!-- GPU Length Multi-Select -->
            <div class="input-group">
                <label>GPU Length</label>
                <div id="multiLength" class="multi-select-container">
                    <div class="multi-select-display" onclick="toggleDropdown('lengthDropdown')">Any</div>
                    <div id="lengthDropdown" class="multi-dropdown">
                        <div class="quick-filter-bar">
                            <button class="filter-btn btn-clear" onclick="clearFilter('length')">Clear Selection</button>
                        </div>
                        <div class="dropdown-list-container" id="lengthListContainer"></div>
                    </div>
                </div>
            </div>

            <!-- Specific Motherboard Multi-Select -->
            <div class="input-group">
                <label>Specific Motherboard(s)</label>
                <div id="multiMobo" class="multi-select-container">
                    <div class="multi-select-display" onclick="toggleDropdown('moboDropdown')">Any</div>
                    <div id="moboDropdown" class="multi-dropdown">
                        <div class="quick-filter-bar">
                            <button class="filter-btn btn-clear" onclick="clearFilter('moboNames')">Clear</button>
                        </div>
                        <div class="dropdown-search-container">
                            <input type="text" class="dropdown-search" placeholder="Filter Motherboards..." oninput="filterDropdownList(this)">
                        </div>
                        <div class="dropdown-list-container" id="moboListContainer"></div>
                    </div>
                </div>
            </div>

            <!-- Specific Case Multi-Select -->
            <div class="input-group">
                <label>Specific Case(s)</label>
                <div id="multiCase" class="multi-select-container">
                    <div class="multi-select-display" onclick="toggleDropdown('caseDropdown')">Any</div>
                    <div id="caseDropdown" class="multi-dropdown">
                        <div class="quick-filter-bar">
                            <button class="filter-btn btn-clear" onclick="clearFilter('caseNames')">Clear</button>
                        </div>
                        <div class="dropdown-search-container">
                            <input type="text" class="dropdown-search" placeholder="Filter Cases..." oninput="filterDropdownList(this)">
                        </div>
                        <div class="dropdown-list-container" id="caseListContainer"></div>
                    </div>
                </div>
            </div>

             <!-- Specific SSD Multi-Select -->
             <div class="input-group">
                <label>Specific SSD (Quantity)</label>
                <div id="multiSSD" class="multi-select-container">
                    <div class="multi-select-display" onclick="toggleDropdown('ssdDropdown')">Any</div>
                    <div id="ssdDropdown" class="multi-dropdown">
                        <div class="quick-filter-bar" id="ssdQuickFilter">
                            <button class="filter-btn btn-clear" onclick="clearFilter('ssdNames')">Clear / Show All</button>
                        </div>
                        <div class="dropdown-search-container">
                            <input type="text" class="dropdown-search" placeholder="Filter SSDs..." oninput="filterDropdownList(this)">
                        </div>
                        <div class="dropdown-list-container" id="ssdListContainer"></div>
                    </div>
                </div>
            </div>

            <!-- Specific HDD Multi-Select -->
            <div class="input-group">
                <label>Specific HDD (Quantity)</label>
                <div id="multiHDD" class="multi-select-container">
                    <div class="multi-select-display" onclick="toggleDropdown('hddDropdown')">Any</div>
                    <div id="hddDropdown" class="multi-dropdown">
                        <div class="quick-filter-bar" id="hddQuickFilter">
                            <button class="filter-btn btn-clear" onclick="clearFilter('hddNames')">Clear / Show All</button>
                        </div>
                        <div class="dropdown-search-container">
                            <input type="text" class="dropdown-search" placeholder="Filter HDDs..." oninput="filterDropdownList(this)">
                        </div>
                        <div class="dropdown-list-container" id="hddListContainer"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="section-header">5. Power Constraints</div>
        <div class="input-grid">
            <div class="input-group">
                <label>Max Total Watts</label>
                <input type="number" id="maxTotalWatts" placeholder="No Limit">
            </div>
            <div class="input-group">
                <label>Max CPU Watts</label>
                <input type="number" id="maxCpuWatts" placeholder="No Limit">
            </div>
            <div class="input-group">
                <label>Max GPU Watts</label>
                <input type="number" id="maxGpuWatts" placeholder="No Limit">
            </div>
            <div class="input-group">
                <label>Extra Watts Buffer (OC Suggestion: ~50)</label>
                <input type="number" id="extraWatts" value="0">
            </div>
        </div>
        
        <button class="btn-generate" onclick="generateBuilds()">GENERATE BUILDS</button>
    </div>

    <!-- Results Meta Bar -->
    <div class="results-meta">
        <div style="display: flex; align-items: center;">
            <div class="result-count" id="resCount">Ready</div>
            <!-- NEW: Score Range Display Text Positioned Here -->
            <div class="score-range-text" id="scoreRangeDisplay"></div>
        </div>
        <div class="sort-controls">
            <!-- IMPLEMENTATION: OVERCLOCK TOGGLE -->
            <div class="checkbox-container" style="margin-right: 15px;">
                <input type="checkbox" id="useOC" onchange="generateBuilds()">
                <label for="useOC">Use CPU overclocked values</label>
            </div>

            <label>Sort By:</label>
            <select id="mainSort" class="sort-select" onchange="renderPage(1)">
                <option value="diff">Closest to Target Score</option>
                <option value="gpu_score">Highest Individual GPU Score</option>
                <option value="cpu_score">Highest Individual CPU Score</option>
                <option value="score_desc">Highest Total Score</option>
                <option value="score_asc">Lowest Total Score</option>
                <option value="price_asc">Lowest Price</option>
                <option value="price_desc">Highest Price</option>
                <option value="value_desc">Most Overperforming (Best Value)</option>
                <option value="value_asc">Most Underperforming (Worst Value)</option>
            </select>

            <div class="min-score-container">
                <label class="min-score-label">Min 3D Score (press enter to apply):</label>
                <input type="text" id="minScoreInput" placeholder="0" onchange="generateBuilds()">
            </div>
        </div>
    </div>


    <div id="resultsList"></div>

    <div class="pagination" id="pagination">
        <button class="page-btn" id="btnPrev" onclick="changePage(-1)">Previous</button>
        <div class="page-info-container" style="flex:1; display:flex; justify-content:center;">
            <span class="page-info" id="pageInfo" onclick="makePageEditable()" title="Click to jump to page">Page 1 of 1</span>
        </div>
        <button class="page-btn" id="btnNext" onclick="changePage(1)">Next</button>
    </div>
</div>

<script>
    // ==================== UNIQUE STORAGE SYSTEM ====================
    const DB = { 
        cpu: new Map(), 
        gpu: new Map(), 
        ram: new Map(), 
        mobo: new Map(), 
        cases: new Map(), 
        psu: new Map(), 
        cooler: new Map(), 
        fan: new Map(),
        storage: new Map()
    };
    
    const Loaded = { cpu: false, gpu: false, ram: false, mobo: false, cases: false, psu: false, cooler: false, fan: false, storage: false };

    // Selected filters for multi-selects
    const selectedOptions = {
        vram: new Set(),
        length: new Set(),
        socket: new Set(),
        cpuNames: new Set(),
        gpuNames: new Set(),
        gpuCount: new Set(), // New: GPU Count Filter
        moboNames: new Set(),
        caseNames: new Set(),
        ramNames: new Set(),
        ramSizes: new Set(), // Reverted to Multi-Select (Stick Sizes)
        ramMfgrs: new Set(), // Filter by Manufacturer
        ramFreqs: new Set(), // New: Filter by Frequency
        // Changed to Map to store Counts for storage
        ssdNames: new Map(), // name -> count
        hddNames: new Map()  // name -> count
    };

    let lastClickedOption = { category: null, index: -1 };
    let warningDismissed = false; // Flag to track dismissal

    const filterKeywords = {
        cpuNames: {
            'AMD': ['AMD', 'Ryzen', 'Threadripper'],
            'Intel': ['Intel', 'Core', 'Pentium', 'Celeron']
        },
        gpuNames: {
            'NVIDIA': ['NVIDIA', 'GeForce', 'RTX', 'GTX', 'PNY', 'Palit', 'Colorful', 'ZOTAC', 'EVGA', 'ASUS'],
            'AMD': ['AMD', 'Radeon', 'RX', 'ASRock', 'Sapphire'],
            'Intel': ['Intel Arc', 'Arc A', 'Arc B']
        },
        socket: {
            'AMD': ['AM4', 'AM5', 'TR4', 'sTRX4'],
            'Intel': ['LGA 1151', 'LGA 1200', 'LGA 1700', 'LGA 1851', 'LGA 2066']
        }
    };

    let builds = [];
    let currentMode = 'TS';
    let currentPage = 1;
    let itemsPerPage = 100;
    let currentPopupData = null;

    // ==================== UTILITY FUNCTIONS ====================
    const formatCurrency = num => '$' + num.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
    const formatNumber = num => num.toLocaleString('en-US');
    const parseVal = id => parseFloat(document.getElementById(id).value.replace(/,/g, '')) || 0;
    const parseIntVal = id => parseInt(document.getElementById(id).value.replace(/,/g, '')) || 0;

    // Helper to convert "1TB", "500GB", "500" into raw GB value
    function parseStorageInput(str) {
        if (!str) return 0;
        str = str.toUpperCase().trim();
        let val = parseFloat(str);
        if (isNaN(val)) return 0;
        if (str.includes('TB')) return val * 1024;
        return val; // Default to GB
    }

    // ==================== INPUT FORMATTING ====================
    ['budget', 'targetScore', 'minScoreInput', 'resLimit'].forEach(id => {
        const el = document.getElementById(id);
        if(el) {
            el.addEventListener('input', e => {
                let v = e.target.value.replace(/\D/g, '');
                e.target.value = v ? parseInt(v).toLocaleString('en-US') : '';
            });
        }
    });

    // ==================== MODE SELECTION ====================
    function setMode(m) {
        currentMode = m;
        document.getElementById('btnTS').classList.toggle('active', m === 'TS');
        document.getElementById('btnTSX').classList.toggle('active', m === 'TSX');
        if(Loaded.cpu && Loaded.gpu) generateBuilds();
    }

    function dismissWarning() {
        document.getElementById('perfWarning').classList.add('hidden');
        warningDismissed = true;
    }

    // ==================== AUTO-FETCHER LOGIC ====================
    window.addEventListener('DOMContentLoaded', initAutoFetcher);

    async function initAutoFetcher() {
        Object.keys(DB).forEach(k => DB[k].clear());
        Object.keys(Loaded).forEach(k => Loaded[k] = false);

        const targets = [
            { id: 'cpu',       file: 'CPU.txt',              label: 'CPU' },
            { id: 'gpu',       file: 'GPU.txt',              label: 'GPU' },
            { id: 'water_gpu', file: 'Water Cooled GPU.txt', label: 'Water GPU' },
            { id: 'ram',       file: 'RAM.txt',              label: 'RAM' },
            { id: 'mobo',      file: 'Motherboard.txt',      label: 'Motherboard' },
            { id: 'cases',     file: 'Cases.txt',            label: 'Cases' },
            { id: 'cooler',    file: 'Coolers.txt',          label: 'Cooler' },
            { id: 'psu',       file: 'PSU.txt',              label: 'PSU' },
            { id: 'fan',       file: 'Case Fans.txt',        label: 'Fans' },
            { id: 'storage',   file: 'Storage.txt',          label: 'Storage' }
        ];

        const loadingText = document.getElementById('loadingText');

        for (const t of targets) {
            loadingText.innerText = `Fetching ${t.label}...`;
            try {
                const response = await fetch(`datas/${t.file}`);
                if (!response.ok) throw new Error(`Status ${response.status}`);
                const text = await response.text();
                
                parseHTML(t.file, text);

            } catch (err) {
                console.warn(`Could not load ${t.file}:`, err);
            }
        }

        // All done
        loadingText.innerText = "Processing Data...";
        setTimeout(() => {
             document.getElementById('loadingOverlay').style.opacity = '0';
             setTimeout(() => {
                 document.getElementById('loadingOverlay').style.display = 'none';
             }, 500);
        }, 500);
    }

    // ==================== FILE PARSING ====================
    function parseHTML(fname, html) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const rows = Array.from(doc.querySelectorAll('tr'));
        if (rows.length < 2) return 0;

        const headers = Array.from(rows[0].querySelectorAll('td')).map(td => td.getAttribute('div') || td.textContent.trim());
        const idx = {};
        headers.forEach((h, i) => idx[h] = i);
        const get = (cells, key) => (idx[key] !== undefined && cells[idx[key]]) ? cells[idx[key]].textContent.trim() : '';

        // Determine File Type based on name
        let type = '';
        const n = fname.toLowerCase();
        
        if (n.includes('cpu.txt')) type = 'cpu';
        else if (n.includes('gpu')) type = 'gpu';
        else if (n.includes('ram')) type = 'ram';
        else if (n.includes('motherboard')) type = 'mobo';
        else if (n.includes('cases')) type = 'cases';
        else if (n.includes('cooler')) type = 'cooler';
        else if (n.includes('psu') || n.includes('power supplies')) type = 'psu';
        else if (n.includes('case fans') || n.includes('fans')) type = 'fan';
        else if (n.includes('storage')) type = 'storage';

        if (!type) return 0;

        let addedCount = 0; 

        for (let i = 1; i < rows.length; i++) {
            const cells = rows[i].querySelectorAll('td');
            if (!cells.length) continue;
            
            const price = parseFloat(get(cells, 'Price'));
            if (isNaN(price) || price <= 0) continue;

            const base = {
                name: get(cells, 'Part Name'),
                price: price,
                level: parseInt(get(cells, 'Level')) || 0,
                mfgr: get(cells, 'Manufacturer')
            };

            if (type === 'cpu') {
                base.scoreTS = parseInt(get(cells, 'Basic CPU Score (TS)')) || 0;
                base.scoreTSX = parseInt(get(cells, 'Basic CPU Score (TSX)')) || 0;
                if (!base.scoreTS) base.scoreTS = base.scoreTSX;
                base.socket = get(cells, 'CPU Socket');
                base.series = get(cells, 'CPU Series');
                base.watts = parseInt(get(cells, 'Wattage')) || 0;
                
                // IMPLEMENTATION: Parse Data for Live Calculation
                base.coreClockMultTS = parseFloat(get(cells, 'Core Clock Multiplier (TS)')) || 0;
                base.multTS = parseFloat(get(cells, 'Mem Clock Multiplier (TS)')) || 0;
                base.memChannelMultTS = parseFloat(get(cells, 'Mem Channels Multiplier (TS)')) || 0;
                base.finalAdjTS = parseFloat(get(cells, 'Final Adjustment (TS)')) || 0;

                base.coreClockMultTSX = parseFloat(get(cells, 'Core Clock Multiplier (TSX)')) || 0;
                base.multTSX = parseFloat(get(cells, 'Mem Clock Multiplier (TSX)')) || 0;   
                base.memChannelMultTSX = parseFloat(get(cells, 'Mem Channels Multiplier (TSX)')) || 0;
                base.finalAdjTSX = parseFloat(get(cells, 'Final Adjustment (TSX)')) || 0;

                base.maxMemChannels = parseInt(get(cells, 'Max Memory Channels')) || 2;
                base.defaultMem = parseInt(get(cells, 'Default Memory Speed')) || 2133;
                base.memTypes = get(cells, 'Supported Memory Types');
                base.cores = get(cells, 'Cores');
                base.maxFreq = get(cells, 'Frequency'); 
                base.baseFreq = get(cells, 'Base Frequency');
                base.voltage = get(cells, 'Voltage');
                base.maxVoltage = get(cells, 'Max Voltage');
                base.canOC = get(cells, 'Can Overclock');
                base.ocScore = get(cells, 'Overclock Basic CPU Score') || "-";
                base.canDelid = get(cells, 'Can Delid');
            } else if (type === 'gpu') {
                base.score = parseInt(get(cells, 'Single GPU Graphics Score')) || 0;
                base.score2 = parseInt(get(cells, 'Double GPU Graphics Score')) || 0;
                base.score3 = parseInt(get(cells, 'Triple GPU Graphics Score')) || 0;
                base.score4 = parseInt(get(cells, 'Quad GPU Graphics Score')) || 0;
                base.watts = parseInt(get(cells, 'Wattage')) || 0;
                base.vram = parseInt(get(cells, 'VRAM (GB)')) || 0;
                base.length = parseInt(get(cells, 'Length')) || 0;
                base.multi = get(cells, 'Double GPU supported') === 'Yes';
                base.sliType = get(cells, 'Double GPU SLI') === 'Yes' ? 'SLI' : 'Crossfire';
                base.isWater = n.includes('water');
                
                base.baseCore = get(cells, 'Base Core Clock Freq');
                base.baseMem = get(cells, 'Base Mem Clock Freq');
                base.maxCore = get(cells, 'GPU max clock');
                base.maxMem = get(cells, 'GPU max mem clock');
                base.chipset = get(cells, 'Chipset');

            } else if (type === 'ram') {
                base.freq = parseInt(get(cells, 'Frequency')) || 0;
                base.type = get(cells, 'Ram Type');
                base.size = parseInt(get(cells, 'Size each (GB)')) || 0;
                base.totalSize = parseInt(get(cells, 'Total Size (GB)')) || 0;
                base.voltage = get(cells, 'Voltage');
                base.maxVoltage = get(cells, 'Max Voltage');
                base.maxSpeed = parseInt(get(cells, 'Max Speed')) || 0;
                // Specific extraction for RAM Manufacturer and Type pairing logic
                base.mfgr = get(cells, 'Manufacturer');
                if(!base.mfgr) base.mfgr = get(cells, 'Brand'); // Fallback
            } else if (type === 'mobo') {
                base.socket = get(cells, 'CPU Socket');
                base.ramType = get(cells, 'Ram Type');
                base.size = get(cells, 'Motherboard Size');
                base.pciSlots = parseInt(get(cells, 'PCI Slots')) || 0;
                base.supportSLI = get(cells, 'Support SLI') === 'Yes';
                base.supportCF = get(cells, 'Support Crossfire') === 'Yes';
            } else if (type === 'cases') {
                base.size = get(cells, 'Case Size');
                base.moboSizes = get(cells, 'Motherboard Size');
                base.maxGpuLen = parseInt(get(cells, 'Max GPU length')) || 0;
                base.maxCpuHeight = parseInt(get(cells, 'Max CPU Fan Height')) || 0;
                base.maxPsuLen = parseInt(get(cells, 'Max PSU length')) || 0;
                base.radSizes = get(cells, 'Max Radiator Sizes') || "";
                base.gpuSlots = parseInt(get(cells, 'GPU Slots')) || 0;
                base.ssdSlots = parseInt(get(cells, 'SSD Slots')) || 0;
                base.hddSlots = parseInt(get(cells, 'HDD Slots')) || 0;
            } else if (type === 'cooler') {
                base.type = get(cells, 'Type');
                base.height = parseInt(get(cells, 'Height')) || 0;
                base.size = parseInt(get(cells, 'Size')) || 0;
                base.sockets = get(cells, 'CPU Socket List');
                base.flow = parseFloat(get(cells, 'Air Flow')) || 0;
            } else if (type === 'psu') {
                base.watts = parseInt(get(cells, 'Wattage')) || 0;
                base.length = parseInt(get(cells, 'Length')) || 0;
            } else if (type === 'fan') {
                base.size = parseInt(get(cells, 'Size')) || 0;
                base.flow = parseFloat(get(cells, 'Air Flow')) || 0;
            } else if (type === 'storage') {
                let sizeVal = parseFloat(get(cells, 'Size (GB)')) || 0;
                base.sizeGB = sizeVal;
                
                if (sizeVal >= 1000) base.sizeStr = (sizeVal / 1000) + 'TB';
                else base.sizeStr = sizeVal + 'GB';

                let speedRaw = get(cells, 'Speed'); 
                if (!speedRaw) speedRaw = get(cells, 'Transfer Speed');
                base.speed = parseInt((speedRaw || "0").replace(/[^0-9]/g, '')) || 0;
                
                base.type = get(cells, 'Type');
                base.mfgr = get(cells, 'Manufacturer');
            }

            DB[type].set(base.name, base);
            addedCount++; 
        }

        Loaded[type] = true;
        updateStatus();
        return addedCount; 
    }

    // Helper for RAM Pairing Logic: Manufacturers must match, Ram Type must match
    function areRamsCompatible(ramA, ramB) {
        if (!ramA || !ramB) return false;
        if (ramA.type !== ramB.type) return false;
        if (ramA.mfgr && ramB.mfgr && ramA.mfgr !== ramB.mfgr) return false;
        return true;
    }

    function updateStatus() {
        if (Loaded.cpu && Loaded.gpu && Loaded.mobo && Loaded.ram && Loaded.cases && Loaded.storage) {
            document.querySelector('.controls-wrapper').classList.add('active');
            refreshDropdowns();
        }
    }

    // Determines Maximum Supported GPU Count based on specific Whitelist
    function getMultiGPUCap(name, length) {
        const n = name.toLowerCase();
        const len = length || 0;

        // Quad Support (4)
        if (n.includes('r9 280')) return 4;
        if (n.includes('r9 290')) return 4;
        if (n.includes('gtx 970') && !n.includes('msi gtx 970 gaming 4g')) return 4;

        // Triple Support (3)
        if (n.includes('rx vega 56')) return 3;
        if (n.includes('radeon vii')) return 3;
        if (n.includes('rx 470') || n.includes('rx 560') || n.includes('rx 570') || n.includes('rx 580') || n.includes('rx 590')) return 3;
        if (n.includes('msi gtx 970 gaming 4g')) return 3;
        if (n.includes('msi gtx 980 ti gaming 6g golden edition')) return 3;
        if (n.includes('rx 5500')) return 3;
        if (n.includes('rtx 2060') && len < 271) return 3;
        if (n.includes('gtx 1080 ti') && len < 290) return 3;

        // Double Support (2)
        if (n.includes('rx 6800 xt')) return 2;
        if (n.includes('gtx 1080 ti')) return 2; // len >= 290
        if (n.includes('gtx 1070 ti')) return 2;
        if (n.includes('rx 5700')) return 2;
        if (n.includes('rtx 2060')) return 2; // len >= 271
        if (n.includes('rtx 2070')) return 2;
        if (n.includes('rtx 3060') || n.includes('rtx 3080') || n.includes('rtx 3090')) return 2;

        // Default: Single GPU Only (1)
        return 1;
    }

    // ==================== REAL-TIME LEVEL FILTERING ====================
    function refreshDropdowns() {
        if (!Loaded.cpu) return;

        const currentLvl = parseInt(document.getElementById('level').value) || 30;
        
        // GPU Count logic check
        // We will just check if multiple counts are selected or if a count > 1 is selected
        let gpuCnt = 1; 
        if(selectedOptions.gpuCount.has(2) || selectedOptions.gpuCount.has(3) || selectedOptions.gpuCount.has(4)) gpuCnt = 2;

        // Filter Logic for Multi-GPU Requirements
        let moboFilterMinPCI = 0;
        let caseFilterMinGPU = 0;

        if (gpuCnt > 1) {
            moboFilterMinPCI = 5;
            caseFilterMinGPU = 3;
        }

        const cpus = Array.from(DB.cpu.values()).filter(c => c.level <= currentLvl);
        const gpus = Array.from(DB.gpu.values()).filter(g => g.level <= currentLvl);
        const rams = Array.from(DB.ram.values()).filter(r => r.level <= currentLvl);
        const allStorage = Array.from(DB.storage.values()).filter(s => s.level <= currentLvl);
        
        const ssdList = allStorage.filter(s => s.type === 'SSD' || s.type === 'M.2');
        const hddList = allStorage.filter(s => s.type === 'HDD');
        
        const mobos = Array.from(DB.mobo.values()).filter(m => 
            m.level <= currentLvl && m.pciSlots >= moboFilterMinPCI
        );
        
        const cases = Array.from(DB.cases.values()).filter(c => 
            c.level <= currentLvl && c.gpuSlots >= caseFilterMinGPU
        );

        // Populate Dropdowns
        populateMultiSelect('gpuCount', [1, 2, 3, 4], 'gpuCountListContainer');
        populateMultiSelect('socket', [...new Set(cpus.map(c => c.socket).filter(s => s))].sort(), 'socketListContainer');
        populateMultiSelect('cpuNames', cpus.map(c => c.name).sort(), 'cpuListContainer');
        populateMultiSelect('vram', [...new Set(gpus.map(g => g.vram).filter(v => v))].sort((a,b) => a-b), 'vramListContainer');
        populateMultiSelect('length', [...new Set(gpus.map(g => g.length).filter(l => l))].sort((a,b) => a-b), 'lengthListContainer');
        populateMultiSelect('gpuNames', [...new Set(gpus.map(g => g.name))].sort(), 'gpuListContainer');
        populateMultiSelect('moboNames', mobos.map(m => m.name).sort(), 'moboListContainer');
        populateMultiSelect('caseNames', cases.map(c => c.name).sort(), 'caseListContainer');
        populateMultiSelect('ramNames', rams.map(r => r.name).sort(), 'ramListContainer');
        
        // Populating SSD and HDD dropdowns
        populateMultiSelect('ssdNames', ssdList.map(s => s.name).sort(), 'ssdListContainer');
        populateMultiSelect('hddNames', hddList.map(s => s.name).sort(), 'hddListContainer');
        
        // Populate RAM Manufacturers
        populateMultiSelect('ramMfgrs', [...new Set(rams.map(r => r.mfgr).filter(m => m))].sort(), 'ramMfgrListContainer');
        // Populate RAM Frequencies
        populateMultiSelect('ramFreqs', [...new Set(rams.map(r => r.freq).filter(f => f))].sort((a,b) => a-b), 'ramFreqListContainer');
        // NEW: Populate RAM Stick Sizes
        populateMultiSelect('ramSizes', [...new Set(rams.map(r => r.size).filter(s => s))].sort((a,b) => a-b), 'ramSizeListContainer');

        // Populate Size Buttons for Storage
        populateStorageSizeButtons('ssd', ssdList);
        populateStorageSizeButtons('hdd', hddList);

        const stickSelect = document.getElementById('ramSticks');
        const fourStickOption = stickSelect.querySelector('option[value="4"]');
        const canSupport4Sticks = mobos.some(m => m.size !== 'Mini-ITX');
        
        if (canSupport4Sticks) {
            fourStickOption.disabled = false;
            fourStickOption.innerText = "4 Sticks";
        } else {
            fourStickOption.disabled = true;
            fourStickOption.innerText = "4 Sticks (Not Available at Level " + currentLvl + ")";
            if(stickSelect.value == "4") stickSelect.value = "2";
        }
    }

    function populateStorageSizeButtons(type, list) {
        const container = document.getElementById(type + 'QuickFilter');
        // Remove old buttons (keep the Clear button)
        const oldBtns = container.querySelectorAll('.btn-size-filter');
        oldBtns.forEach(b => b.remove());

        const uniqueSizes = [...new Set(list.map(s => s.sizeStr))];
        
        // Sort sizes logic: MB < GB < TB
        uniqueSizes.sort((a,b) => {
            const getVal = (str) => {
                let n = parseFloat(str);
                if(str.includes('TB')) n *= 1024 * 1024;
                else if(str.includes('GB')) n *= 1024;
                return n;
            }
            return getVal(a) - getVal(b);
        });

        uniqueSizes.forEach(size => {
            const btn = document.createElement('button');
            btn.className = 'filter-btn btn-size-filter';
            btn.innerText = size;
            btn.onclick = () => applySizeFilter(type, size);
            container.appendChild(btn);
        });
    }

    function applySizeFilter(type, sizeStr) {
        const containerId = type + 'ListContainer';
        const container = document.getElementById(containerId);
        const options = container.querySelectorAll('.multi-option');
        
        // Hide items that don't match the selected size
        options.forEach(opt => {
            if (opt.dataset.sizeStr === sizeStr) {
                opt.style.display = 'flex';
            } else {
                opt.style.display = 'none';
            }
        });
    }

    // ==================== MULTI-SELECT FUNCTIONS ====================
    window.addEventListener('click', function(e) {
        if (!e.target.matches('.multi-select-display') && !e.target.closest('.multi-dropdown')) {
            document.querySelectorAll('.multi-dropdown').forEach(d => d.classList.remove('show'));
        }
    });

    function toggleDropdown(id) {
        const target = document.getElementById(id);
        const isShown = target.classList.contains('show');
        document.querySelectorAll('.multi-dropdown').forEach(d => d.classList.remove('show'));
        if (!isShown) target.classList.add('show');
        const searchInput = target.querySelector('.dropdown-search');
        if (searchInput && !isShown) setTimeout(() => searchInput.focus(), 100);
    }
    
    function populateMultiSelect(category, options, containerId) {
        const container = document.getElementById(containerId);
        container.innerHTML = '';
        const isStorage = (category === 'ssdNames' || category === 'hddNames');

        options.forEach((opt, index) => {
            const div = document.createElement('div');
            div.className = 'multi-option';
            
            // Check selection state
            let isSelected = false;
            let count = 0;

            if (isStorage) {
                if (selectedOptions[category].has(opt)) {
                    isSelected = true;
                    count = selectedOptions[category].get(opt);
                }
                // Attach sizeStr for filtering
                const s = DB.storage.get(opt);
                if(s) div.dataset.sizeStr = s.sizeStr;
            } else {
                if (selectedOptions[category].has(opt)) isSelected = true;
            }

            if (isSelected) div.classList.add('selected');
            div.dataset.value = opt;
            div.dataset.index = index; 
            
            let label = opt;
            
            if (category === 'ramNames') {
                const r = DB.ram.get(opt);
                if (r) {
                    // Include MANUFACTURER explicitly in the dropdown text
                    label = `<span style="font-size:1.2em"><b>${r.mfgr || 'Generic'}</b> - ${r.name} | Size Each: ${r.size}GB | Total: ${r.totalSize}GB | ${r.type} | ${r.freq}/${r.maxSpeed} MHz | ${r.voltage}/${r.maxVoltage} V | Lvl: ${r.level}</span>`;
                }
            } else if (category === 'moboNames') {
                const m = DB.mobo.get(opt);
                if (m) label = `<span style="font-size:0.9em">${m.name} | PCI Slots: ${m.pciSlots}</span>`;
            } else if (category === 'caseNames') {
                const c = DB.cases.get(opt);
                if (c) label = `<span style="font-size:0.9em">${c.name} | GPU Slots: ${c.gpuSlots}</span>`;
            } else if (isStorage) {
                const s = DB.storage.get(opt);
                if (s) {
                    label = `<span style="font-size:0.9em">${s.name} | ${s.sizeStr} | ${s.speed} MB/s</span>`;
                }
            } else {
                if (category === 'vram') label += ' GB';
                if (category === 'length') label += ' mm';
                if (category === 'ramFreqs') label += ' MHz';
                if (category === 'ramSizes') label += ' GB'; // New label for stick size
                if (category === 'gpuCount') {
                     if(opt == 1) label = "Single GPU";
                     if(opt == 2) label = "Dual GPU";
                     if(opt == 3) label = "Triple GPU";
                     if(opt == 4) label = "Quad GPU";
                }
            }

            // HTML Construction
            if (isStorage) {
                // QUANTITY CONTROLS FOR STORAGE
                const safeName = opt.replace(/'/g, "\\'");
                div.innerHTML = `
                    <div class="option-left" onclick="toggleStorageSelection('${category}', '${safeName}', 1)">
                        <div class="cb-custom"></div>
                        <span>${label}</span>
                    </div>
                    <div class="qty-controls" onclick="event.stopPropagation()">
                        <button class="qty-btn" onclick="modifyStorageQty('${category}', '${safeName}', -1)">-</button>
                        <span class="qty-val">${count}</span>
                        <button class="qty-btn" onclick="modifyStorageQty('${category}', '${safeName}', 1)">+</button>
                    </div>
                `;
            } else {
                // STANDARD BOOLEAN SELECTION
                div.innerHTML = `<div class="cb-custom"></div><span>${label}</span>`;
                div.onclick = (e) => toggleOption(category, opt, div, e);
            }
            
            container.appendChild(div);
        });
        
        updateDisplayLabel(category);
    }

    // New Storage Toggle (Sets to 1 if not present, else removes)
    window.toggleStorageSelection = function(category, value, defaultQty) {
        if (selectedOptions[category].has(value)) {
            selectedOptions[category].delete(value);
        } else {
            selectedOptions[category].set(value, defaultQty);
        }
        refreshStorageDropdown(category);
        updateDisplayLabel(category);
    }

    // New Storage Quantity Modifier
    window.modifyStorageQty = function(category, value, delta) {
        let current = selectedOptions[category].get(value) || 0;
        let next = current + delta;
        
        if (next <= 0) {
            selectedOptions[category].delete(value);
        } else {
            selectedOptions[category].set(value, next);
        }
        refreshStorageDropdown(category);
        updateDisplayLabel(category);
    }

    function refreshStorageDropdown(category) {
        const containerId = category === 'ssdNames' ? 'ssdListContainer' : 'hddListContainer';
        const list = (category === 'ssdNames') ? 
            Array.from(DB.storage.values()).filter(s => (s.type === 'SSD' || s.type === 'M.2')) :
            Array.from(DB.storage.values()).filter(s => s.type === 'HDD');
        
        // Save scroll position
        const container = document.getElementById(containerId);
        const scrollTop = container.scrollTop;

        // Re-render
        populateMultiSelect(category, list.map(s=>s.name).sort(), containerId);
        
        // Restore scroll
        container.scrollTop = scrollTop;
    }

    function toggleOption(category, value, element, event) {
        if (event.shiftKey && lastClickedOption.category === category && lastClickedOption.index !== -1) {
            const container = element.parentElement;
            const options = Array.from(container.children).filter(c => c.style.display !== 'none');
            
            const currentIndex = options.indexOf(element);
            const lastIndex = options.findIndex(opt => parseInt(opt.dataset.index) === lastClickedOption.index);

            if (currentIndex !== -1 && lastIndex !== -1) {
                const start = Math.min(currentIndex, lastIndex);
                const end = Math.max(currentIndex, lastIndex);
                
                for (let i = start; i <= end; i++) {
                    const opt = options[i];
                    const val = opt.dataset.value;
                    if(category === 'gpuCount') selectedOptions[category].add(parseInt(val));
                    else selectedOptions[category].add(val);
                    opt.classList.add('selected');
                }
            }
        } 
        else {
            if (selectedOptions[category].has(value)) {
                selectedOptions[category].delete(value);
                element.classList.remove('selected');
            } else {
                selectedOptions[category].add(value);
                element.classList.add('selected');
            }
        }

        lastClickedOption = { 
            category: category, 
            index: parseInt(element.dataset.index) 
        };

        updateDisplayLabel(category);
    }

    function applyQuickFilter(category, type) {
        const keywords = filterKeywords[category][type];
        if (!keywords) return;
        let containerId = category === 'cpuNames' ? 'cpuListContainer' :
                         category === 'gpuNames' ? 'gpuListContainer' : 'socketListContainer';
        const container = document.getElementById(containerId);
        container.querySelectorAll('.multi-option').forEach(opt => {
            const val = opt.dataset.value;
            if (keywords.some(kw => val.includes(kw))) {
                opt.classList.add('selected');
                selectedOptions[category].add(val);
            }
        });
        updateDisplayLabel(category);
    }

    function clearFilter(category) {
        selectedOptions[category].clear();
        let containerId;
        if(category === 'cpuNames') containerId = 'cpuListContainer';
        else if(category === 'gpuNames') containerId = 'gpuListContainer';
        else if(category === 'socket') containerId = 'socketListContainer';
        else if(category === 'vram') containerId = 'vramListContainer';
        else if(category === 'length') containerId = 'lengthListContainer';
        else if(category === 'moboNames') containerId = 'moboListContainer';
        else if(category === 'ramNames') containerId = 'ramListContainer';
        else if(category === 'ramMfgrs') containerId = 'ramMfgrListContainer';
        else if(category === 'ramFreqs') containerId = 'ramFreqListContainer';
        else if(category === 'ramSizes') containerId = 'ramSizeListContainer';
        else if(category === 'gpuCount') containerId = 'gpuCountListContainer';
        else if(category === 'caseNames') containerId = 'caseListContainer';
        else if(category === 'ssdNames') containerId = 'ssdListContainer';
        else if(category === 'hddNames') containerId = 'hddListContainer';

        const container = document.getElementById(containerId);
        // If storage, we need to re-render to reset counts UI and reset Visibility (filtering)
        if (category === 'ssdNames' || category === 'hddNames') {
             refreshStorageDropdown(category);
             // Ensure all are visible after clear
             if(container) container.querySelectorAll('.multi-option').forEach(opt => opt.style.display = 'flex');
        } else {
             if(container) container.querySelectorAll('.multi-option').forEach(opt => opt.classList.remove('selected'));
        }
        
        updateDisplayLabel(category);
    }

    function updateDisplayLabel(category) {
        let displayId;
        switch(category) {
            case 'vram': displayId = 'multiVram'; break;
            case 'length': displayId = 'multiLength'; break;
            case 'socket': displayId = 'multiSocket'; break;
            case 'cpuNames': displayId = 'multiCpu'; break;
            case 'gpuNames': displayId = 'multiGpu'; break;
            case 'gpuCount': displayId = 'multiGpuCount'; break;
            case 'ramNames': displayId = 'multiRam'; break;
            case 'ramMfgrs': displayId = 'multiRamMfgr'; break;
            case 'ramFreqs': displayId = 'multiRamFreq'; break;
            case 'ramSizes': displayId = 'multiRamSize'; break;
            case 'moboNames': displayId = 'multiMobo'; break;
            case 'caseNames': displayId = 'multiCase'; break;
            case 'ssdNames': displayId = 'multiSSD'; break;
            case 'hddNames': displayId = 'multiHDD'; break;
        }

        const display = document.getElementById(displayId).querySelector('.multi-select-display');
        const size = selectedOptions[category].size;

        // Custom logic for Storage display (Sum of counts)
        if (category === 'ssdNames' || category === 'hddNames') {
            let totalCount = 0;
            selectedOptions[category].forEach(qty => totalCount += qty);
            
            if (totalCount === 0) display.textContent = "Any";
            else display.textContent = `${totalCount} drives selected`;
            return;
        }

        if (size === 0) {
            display.textContent = 'Any';
        } else if (size === 1) {
            let val = Array.from(selectedOptions[category])[0];
            if (category === 'vram') val += ' GB';
            if (category === 'length') val += ' mm';
            if (category === 'ramFreqs') val += ' MHz';
            if (category === 'ramSizes') val += ' GB';
            if (category === 'gpuCount') {
                if(val == 1) val = "Single GPU";
                else if(val == 2) val = "Dual GPU";
                else if(val == 3) val = "Triple GPU";
                else if(val == 4) val = "Quad GPU";
            }
            display.textContent = val;
        } else {
            if (['cpuNames','gpuNames','moboNames','caseNames','ramNames', 'ramMfgrs'].includes(category)) {
                display.textContent = `${size} selected`;
            } else {
                const arr = Array.from(selectedOptions[category]).sort((a,b) =>
                    (typeof a === 'number' ? a - b : String(a).localeCompare(String(b)))
                );
                let suffix = (category === 'vram' ? ' GB' : (category === 'length' ? ' mm' : (category === 'ramFreqs' ? ' MHz' : (category === 'ramSizes' ? ' GB' : ''))));
                if(category === 'gpuCount') display.textContent = `${size} configs selected`;
                else display.textContent = `${arr[0]}${suffix} + ${size - 1} others`;
            }
        }
    }

    function filterDropdownList(input) {
        const filter = input.value.toLowerCase();
        const container = input.closest('.multi-dropdown').querySelector('.dropdown-list-container');
        if (!container) return;
        container.querySelectorAll('.multi-option').forEach(item => {
            // Text content includes buttons, so filtering still works mostly on the name span
            item.style.display = item.textContent.toLowerCase().includes(filter) ? 'flex' : 'none';
        });
    }

    // ==================== BRAND COLOR HELPER ====================
    function getBrandClass(item) {
        if (!item) return '';
        if (item.mfgr === 'Intel') {
            if (item.vram !== undefined) return 'brand-intel-gpu'; 
            return 'brand-intel'; 
        }
        if (item.mfgr === 'AMD') return 'brand-amd';
        if (item.mfgr === 'NVIDIA') return 'brand-nvidia';
        const searchStr = (item.name + " " + (item.chipset || "")).toLowerCase();
        if (searchStr.includes('radeon') || searchStr.includes('ryzen') || searchStr.includes('threadripper')) return 'brand-amd';
        if (searchStr.includes('geforce') || searchStr.includes('gtx') || searchStr.includes('rtx')) return 'brand-nvidia';
        if (searchStr.includes('arc ')) return 'brand-intel-gpu';
        return '';
    }

    // ==================== 3DMARK CALCULATION ====================
    
    // IMPLEMENTATION: Live CPU Score Calculator
    function calculateCpuScore(cpu, ram, stickCount, mode, useOC) {
        // 1. Determine Freq
        let rawFreq = useOC ? cpu.maxFreq : cpu.baseFreq;
        let freq = parseFloat(rawFreq) || 0;

        // 2. Select Multipliers
        const isTS = (mode === 'TS');
        const coreMult = isTS ? cpu.coreClockMultTS : cpu.coreClockMultTSX;
        const memChanMult = isTS ? cpu.memChannelMultTS : cpu.memChannelMultTSX;
        const memClockMult = isTS ? cpu.multTS : cpu.multTSX;
        const adjustment = isTS ? cpu.finalAdjTS : cpu.finalAdjTSX;

        // 3. RAM Logic
        let activeChannels, actualMemSpeed;
        if (ram) {
            // Enabled: MIN(Sticks, MaxSupported)
            activeChannels = Math.min(stickCount, cpu.maxMemChannels);
            actualMemSpeed = ram.freq;
        } else {
            // Disabled: Use CPU Defaults
            activeChannels = cpu.maxMemChannels;
            actualMemSpeed = cpu.defaultMem;
        }

        // 4. Formula
        // Score = FLOOR ( ( (CoreMult * Freq) + (ChanMult * ActiveChans) + (MemClockMult * Speed) + Adj ) * 298 )
        const coreScore = coreMult * freq;
        const chanScore = memChanMult * activeChannels;
        const speedScore = memClockMult * actualMemSpeed;
        
        const sum = coreScore + chanScore + speedScore + adjustment;
        const final = Math.floor(sum * 298);

        return final > 0 ? final : 0;
    }

    function calculate3DMark(cpuScore, gpuScore) {
        if (!cpuScore || !gpuScore) return 0;
        return Math.floor(1 / ((0.85 / gpuScore) + (0.15 / cpuScore)));
    }

    function generateBuilds() {
        if (!Loaded.cpu || !Loaded.gpu) return alert("Wait for CPU and GPU files to load from datas/ folder!");

        // PERFORMANCE WARNING CHECK
        // Logic: Show if no filters AND has not been dismissed
        // Includes checks for Stick Size and Target Capacity inputs
        const targetRamVal = parseIntVal('targetTotalRam');
        const ramSpecific = selectedOptions.ramNames.size > 0 || selectedOptions.ramMfgrs.size > 0 || selectedOptions.ramFreqs.size > 0 || selectedOptions.ramSizes.size > 0 || targetRamVal > 0;
        const generalSpecific = selectedOptions.cpuNames.size > 0 || selectedOptions.gpuNames.size > 0;
        const warningBox = document.getElementById('perfWarning');
        
        if (!ramSpecific && !generalSpecific && !warningDismissed) {
            warningBox.classList.remove('hidden');
        } else {
            warningBox.classList.add('hidden');
        }

        const allCpus = Array.from(DB.cpu.values());
        const allGpus = Array.from(DB.gpu.values());
        const allRams = Array.from(DB.ram.values());
        const allMobos = Array.from(DB.mobo.values());
        const allCases = Array.from(DB.cases.values());
        const allCoolers = Array.from(DB.cooler.values());
        const allPsu = Array.from(DB.psu.values());
        const allFans = Array.from(DB.fan.values());
        
        const allStorage = Array.from(DB.storage.values());

        const budget = parseVal('budget');
        const target = parseVal('targetScore');
        const minScore = parseVal('minScoreInput');
        const lvl = parseInt(document.getElementById('level').value);
        
        // NEW: Get GPU Counts from Multi-Select
        let selectedGpuCounts = Array.from(selectedOptions.gpuCount);
        if (selectedGpuCounts.length === 0) selectedGpuCounts = [1, 2, 3, 4];
        // Sort descending to show quad gpu builds first maybe? Or ascending. Let's do ascending for simplicity
        selectedGpuCounts.sort((a,b)=>a-b);

        const maxPoolSize = parseIntVal('resLimit'); 
        const sort = document.getElementById('mainSort').value;
        const useOC = document.getElementById('useOC').checked; // Check Toggle State
        const useRamPerfMode = document.getElementById('ramPerfMode').checked; // NEW Checkbox

        const limitTotalW = parseInt(document.getElementById('maxTotalWatts').value);
        const limitCpuW = parseInt(document.getElementById('maxCpuWatts').value);
        const limitGpuW = parseInt(document.getElementById('maxGpuWatts').value);
        const extraW = parseInt(document.getElementById('extraWatts').value) || 0;

        const useRam = document.getElementById('incRam').checked && Loaded.ram;
        const reqSticks = parseInt(document.getElementById('ramSticks').value);
        const stickCounts = reqSticks === 0 ? [1, 2, 4] : [reqSticks];

        const useMobo = document.getElementById('incMobo').checked && Loaded.mobo;
        const useCase = document.getElementById('incCase').checked && Loaded.cases;
        const useCooler = document.getElementById('incCooler').checked && Loaded.cooler;
        const usePsu = document.getElementById('incPsu').checked && Loaded.psu;
        const useFan = document.getElementById('incFans').checked && Loaded.fan;
        const useStorage = document.getElementById('incStorage').checked && Loaded.storage;
        
        if (useMobo) allMobos.sort((a,b) => a.price - b.price);
        if (useCase) allCases.sort((a,b) => a.price - b.price);
        if (usePsu) allPsu.sort((a,b) => a.price - b.price);
        
        // Smart Sorting Logic
        const getSmartSort = (metric) => (a, b) => {
            // High Score -> High Perf
            if (sort === 'score_desc') return b[metric] - a[metric] || b.price - a.price;
            // Low Score -> Low Perf
            if (sort === 'score_asc') return a[metric] - b[metric] || a.price - b.price;
            // High Price -> High Price
            if (sort === 'price_desc') return b.price - a.price;
            // Low Price / Diff -> Low Price
            if (sort === 'price_asc' || sort === 'diff') return a.price - b.price;
            
            // Value = Perf / Price
            const valA = a[metric] / (a.price || 1);
            const valB = b[metric] / (b.price || 1);
            
            if (sort === 'value_desc') return valB - valA; // Best Value
            if (sort === 'value_asc') return valA - valB; // Worst Value
            
            return a.price - b.price; // Default
        };
        
        if (useCooler) allCoolers.sort(getSmartSort('flow'));
        if (useFan) allFans.sort(getSmartSort('flow'));

        // ================= PRE-CALCULATE STORAGE =================
        let finalStorageList = [];
        let totalStorageCost = 0;
        let requiredSSDSlots = 0;
        let requiredHDDSlots = 0;

        selectedOptions.ssdNames.forEach((count, name) => {
            const part = DB.storage.get(name);
            if (part && part.level <= lvl) {
                for(let i=0; i<count; i++) {
                    finalStorageList.push(part);
                    totalStorageCost += part.price;
                    requiredSSDSlots++;
                }
            }
        });

        selectedOptions.hddNames.forEach((count, name) => {
            const part = DB.storage.get(name);
            if (part && part.level <= lvl) {
                for(let i=0; i<count; i++) {
                    finalStorageList.push(part);
                    totalStorageCost += part.price;
                    requiredHDDSlots++;
                }
            }
        });

        if (useStorage && finalStorageList.length === 0) {
            const fallback = allStorage.filter(s => s.type !== 'HDD' && s.level <= lvl).sort((a,b) => a.price - b.price)[0];
            if (fallback) {
                finalStorageList.push(fallback);
                totalStorageCost += fallback.price;
                requiredSSDSlots++;
            }
        }
        // =========================================================

        const validCpu = allCpus.filter(c => {
            if (c.level > lvl) return false;
            if (limitCpuW && (c.watts || 0) > limitCpuW) return false;
            if (selectedOptions.socket.size > 0 && !selectedOptions.socket.has(c.socket)) return false;
            if (selectedOptions.cpuNames.size > 0 && !selectedOptions.cpuNames.has(c.name)) return false;
            return true;
        });

        // Pre-filter GPU list for general validity
        const validGpuBase = allGpus.filter(g => {
            if (g.level > lvl) return false;
            if (limitGpuW && (g.watts || 0) > limitGpuW) return false;
            if (selectedOptions.vram.size > 0 && !selectedOptions.vram.has(g.vram)) return false;
            if (selectedOptions.length.size > 0 && !selectedOptions.length.has(g.length)) return false;
            if (selectedOptions.gpuNames.size > 0 && !selectedOptions.gpuNames.has(g.name)) return false;
            return true;
        });

        validCpu.sort((a,b) => {
            const scoreA = currentMode === 'TS' ? a.scoreTS : a.scoreTSX;
            const scoreB = currentMode === 'TS' ? b.scoreTS : b.scoreTSX;
            return scoreB - scoreA;
        });

        // Sort GPU Base for single GPU performance initially
        validGpuBase.sort((a,b) => b.score - a.score);

        builds = [];
        
        for (const cpu of validCpu) {
            if (builds.length >= maxPoolSize) break;

            let ramTiers = [];
            if (useRam) {
                // 1. Base Compatibility Filter
                let compatibleRam = allRams.filter(r => 
                    r.level <= lvl && 
                    cpu.memTypes.includes(r.type) && 
                    (selectedOptions.ramNames.size === 0 || selectedOptions.ramNames.has(r.name)) &&
                    (selectedOptions.ramMfgrs.size === 0 || selectedOptions.ramMfgrs.has(r.mfgr)) &&
                    (selectedOptions.ramFreqs.size === 0 || selectedOptions.ramFreqs.has(r.freq)) && // Frequency Check
                    (selectedOptions.ramSizes.size === 0 || selectedOptions.ramSizes.has(r.size)) // Stick Size Check (Multi Select)
                );
                
                // 2. RAM Performance Mode Logic
                if (useRamPerfMode) {
                    const bestValueBySpec = new Map();
                    for (const r of compatibleRam) {
                        // Key includes Type, Size, and Frequency. This finds the single cheapest stick for every unique spec combo.
                        const key = `${r.type}-${r.size}-${r.freq}`; 
                        if (!bestValueBySpec.has(key) || r.price < bestValueBySpec.get(key).price) {
                            bestValueBySpec.set(key, r);
                        }
                    }
                    ramTiers = Array.from(bestValueBySpec.values());
                } else {
                    // Default Logic (Group by Price/Brand mostly)
                     const bestValueBySpec = new Map();
                    for (const r of compatibleRam) {
                        const mfgr = r.mfgr || "Generic";
                        const key = `${r.type}-${mfgr}-${r.freq}-${r.size}`; 
                        if (!bestValueBySpec.has(key) || r.price < bestValueBySpec.get(key).price) {
                            bestValueBySpec.set(key, r);
                        }
                    }
                    ramTiers = Array.from(bestValueBySpec.values());
                }
                
                // 3. Sort RAMs
                ramTiers.sort((a,b) => {
                    if (a.type !== b.type) return a.type.localeCompare(b.type); 
                    if (a.freq !== b.freq) return a.freq - b.freq;
                    if (a.size !== b.size) return a.size - b.size;
                    return a.price - b.price;
                });

            } else {
                ramTiers.push(null); 
            }

            for (const ram of ramTiers) {
                if (builds.length >= maxPoolSize) break;

                for(const sticks of stickCounts) {
                    if (builds.length >= maxPoolSize) break;

                    // CHECK TARGET TOTAL CAPACITY (New Input Box)
                    if (targetRamVal > 0) {
                        if (ram && (ram.size * sticks) !== targetRamVal) continue;
                    }

                    let ramCost = 0;
                    if (ram) ramCost = ram.price * sticks;
    
                    // IMPLEMENTATION: Use LIVE score logic
                    const liveCpuScore = calculateCpuScore(cpu, ram, sticks, currentMode, useOC);
                    
                    if (liveCpuScore === 0) continue; // Skip invalid configs

                    let mobo = null;
                    if (useMobo) {
                        const type = ram ? ram.type : (cpu.memTypes.includes('DDR4') ? 'DDR4' : 'DDR5');
                        
                        // Mobo filter needs to know GPU count roughly to filter PCI slots.
                        // We take the MAX selected GPU count to ensure mobo is compatible with worst case,
                        // OR we iterate mobos inside GPU loop. Iterating inside is safer but slower.
                        // Let's optimize: Filter Mobos here assuming max requirement, then verify inside.
                        const maxSelectedGpu = Math.max(...selectedGpuCounts);
                        const minPci = maxSelectedGpu > 1 ? 5 : 0;

                        const found = allMobos.find(m =>
                            m.level <= lvl &&
                            m.socket === cpu.socket &&
                            m.ramType === type &&
                            (selectedOptions.moboNames.size === 0 || selectedOptions.moboNames.has(m.name))
                        );
                        if (!found) continue; 
                        mobo = found; 
                        
                        if (sticks === 4 && mobo.size === 'Mini-ITX') continue;
                    }

                    // LOOP THROUGH SELECTED GPU COUNTS
                    for (const gpuCnt of selectedGpuCounts) {
                        if (builds.length >= maxPoolSize) break;
                        
                        // Check mobo slots again for this specific count
                        if (mobo && gpuCnt > 1 && mobo.pciSlots < 5) continue;

                        for (const gpu of validGpuBase) {
                            if (gpuCnt === 2 && !gpu.score2) continue;
                            if (gpuCnt === 3 && !gpu.score3) continue;
                            if (gpuCnt === 4 && !gpu.score4) continue;

                            if (gpuCnt > 1) {
                                // Multi-GPU Cap Check
                                const maxCap = getMultiGPUCap(gpu.name, gpu.length);
                                if (maxCap < gpuCnt) continue;

                                if (mobo) {
                                    if (gpu.sliType === 'SLI' && !mobo.supportSLI) continue;
                                    if (gpu.sliType === 'Crossfire' && !mobo.supportCF) continue;
                                }
                            }

                            let gpuScore = gpuCnt === 1 ? gpu.score :
                                          gpuCnt === 2 ? gpu.score2 :
                                          gpuCnt === 3 ? gpu.score3 : gpu.score4;
                            if (!gpuScore) continue;

                            let bCase = null;
                            if (useCase) {
                                const found = allCases.find(c => {
                                    if (c.level > lvl) return false;
                                    if (c.maxGpuLen < gpu.length) return false;
                                    if (mobo && !c.moboSizes.includes(mobo.size)) return false;
                                    if (selectedOptions.caseNames.size > 0 && !selectedOptions.caseNames.has(c.name)) return false;
                                    
                                    if (gpuCnt > 1) {
                                        if (c.gpuSlots < 3) return false;
                                    }

                                    if (requiredSSDSlots > c.ssdSlots) return false;
                                    if (requiredHDDSlots > c.hddSlots) return false;

                                    return true;
                                });
                                if (!found) continue;
                                bCase = found; 
                            }

                            let cooler = null;
                            if (useCooler) {
                                cooler = allCoolers.find(c => checkFit('cooler', c, {cpu, case: bCase}));
                                if(!cooler) cooler = { name: "None (No Fit)", price: 0, level: 0, type: "N/A", height: 0, size: 0, flow: 0, sockets: [] };
                            }

                            let psu = null;
                            const totalWatts = cpu.watts + (gpu.watts * gpuCnt) + extraW;
                            
                            if (usePsu) {
                                const found = allPsu.find(p => {
                                    if (p.level > lvl) return false;
                                    if (p.watts < totalWatts) return false;
                                    if (bCase && bCase.maxPsuLen > 0 && p.length > bCase.maxPsuLen) return false;
                                    return true;
                                });
                                if (!found) continue;
                                psu = found;
                            }

                            let fan = null, fanCost = 0;
                            if (useFan && bCase) {
                                const found = allFans.find(f => checkFit('fan', f, {case: bCase}));
                                if(found) {
                                    fan = found;
                                    fanCost = found.price;
                                }
                            }

                            if (limitTotalW && totalWatts > limitTotalW) continue;

                            let total = cpu.price + (gpu.price * gpuCnt) + ramCost + fanCost + totalStorageCost;
                            if (mobo) total += mobo.price;
                            if (bCase) total += bCase.price;
                            if (cooler) total += cooler.price;
                            if (psu) total += psu.price;

                            if (total > budget) continue;

                            // Use LIVE CPU SCORE in final calc
                            const final3D = calculate3DMark(liveCpuScore, gpuScore);
                            if (minScore > 0 && final3D < minScore) continue;

                            builds.push({
                                score: final3D,
                                liveCpuScore: liveCpuScore, // Store calculated score for Sorting
                                gpuScore: gpuScore, // Store specific GPU Score for Sorting
                                diff: final3D - target,
                                price: total,
                                watts: totalWatts,
                                cpu, gpu, gpuCnt, ram, ramSticks: sticks, mobo,
                                case: bCase, cooler, psu, fan, 
                                storages: [...finalStorageList] 
                            });
                            
                            if (builds.length >= maxPoolSize) break;
                        }
                    }
                }
            } 
        }

        // Initially sort based on selection (Optimization: do not just rely on renderPage for the first heavy lift)
        sortBuildsArray(builds, sort);

        // NEW: Update Lowest/Highest Score Text
        const scoreRangeDisplay = document.getElementById('scoreRangeDisplay');
        if (builds.length > 0) {
            // Find Min and Max Score in the generated list
            let minS = builds[0].score;
            let maxS = builds[0].score;
            // Iterate fast through current pool
            for(let i=1; i<builds.length; i++){
                if(builds[i].score < minS) minS = builds[i].score;
                if(builds[i].score > maxS) maxS = builds[i].score;
            }
            scoreRangeDisplay.innerText = `Lowest score in list: ${formatNumber(minS)} | Highest Score in list: ${formatNumber(maxS)}`;
        } else {
            scoreRangeDisplay.innerText = "";
        }

        if (builds.length > maxPoolSize) {
            builds = builds.slice(0, maxPoolSize);
        }

        document.getElementById('resCount').innerText = `${builds.length} Builds Found`;
        document.getElementById('pagination').style.display = builds.length > 0 ? 'flex' : 'none';
        renderPage(1);
    }
    
    // Extracted Sort Logic so renderPage can call it instantly without regeneration
    function sortBuildsArray(array, sortType) {
        array.sort((a,b) => {
            if (sortType === 'score_desc') return b.score - a.score;
            if (sortType === 'score_asc') return a.score - b.score;
            if (sortType === 'price_asc') return a.price - b.price;
            if (sortType === 'price_desc') return b.price - a.price;
            
            // New Individual Sorts
            if (sortType === 'gpu_score') return b.gpuScore - a.gpuScore;
            if (sortType === 'cpu_score') return b.liveCpuScore - a.liveCpuScore;

            if (sortType === 'value_desc') return (b.score / b.price) - (a.score / a.price);
            if (sortType === 'value_asc') return (a.score / a.price) - (b.score / b.price);
            return Math.abs(a.diff) - Math.abs(b.diff); 
        });
    }

    function renderPage(page) {
        if (!builds.length) {
            document.getElementById('resultsList').innerHTML = '<div style="text-align:center;padding:40px;color:#e74c3c;font-size:1.4em;">No Builds Found</div>';
            return;
        }

        const sort = document.getElementById('mainSort').value;
        const useOC = document.getElementById('useOC').checked;
        
        // "Flawless" sorting: Just resort the existing array in memory
        sortBuildsArray(builds, sort);

        currentPage = page;
        const start = (page - 1) * itemsPerPage;
        const end = start + itemsPerPage;
        const slice = builds.slice(start, end);
        const total = Math.ceil(builds.length / itemsPerPage);

        const list = document.getElementById('resultsList');
        list.innerHTML = '';

        slice.forEach((b, i) => {
            const diffClass = b.diff > 0 ? 'diff-pos' : 'diff-neg';
            const sign = b.diff > 0 ? '+' : '';
            const gpuClass = getBrandClass(b.gpu);
            const cpuClass = getBrandClass(b.cpu);
            const buildIdx = start + i;

            const gpuCountStr = b.gpuCnt > 1 ? `${b.gpuCnt}x ` : '';
            const gpuEmoji = b.gpu.isWater ? 'ðŸ’§' : 'ðŸ’¨';
            
            const gpuSpecs = `
                Score: ${formatNumber(b.gpuScore)} | ${b.gpu.vram}GB | ${b.gpu.length}mm | ${b.gpu.watts * b.gpuCnt}W | ${gpuEmoji} | 
                Base Core/Max Core: ${b.gpu.baseCore || '?'}/${b.gpu.maxCore || '?'} MHz | 
                Base Mem/Max Mem: ${b.gpu.baseMem || '?'}/${b.gpu.maxMem || '?'} MHz
            `;
            
            // Display Live Score with new formatting logic based on OC Toggle
            const displayCpuScore = b.liveCpuScore;
            const baseScoreVal = currentMode === 'TS' ? b.cpu.scoreTS : b.cpu.scoreTSX;
            const ocStatus = useOC ? "(OC Enabled)" : "(Base)";
            
            let cpuSpecs = "";
            
            if (useOC) {
                // If Overclocked is Checked: Show OC Score first
                cpuSpecs = `
                    OC Score: ${formatNumber(displayCpuScore)} | Base Score: ${formatNumber(baseScoreVal)} | ${b.cpu.socket} | ${b.cpu.cores} Cores | 
                    ${b.cpu.baseFreq || '?'} / ${b.cpu.maxFreq || '?'} MHz | 
                    ${b.cpu.voltage || '?'}/${b.cpu.maxVoltage || '?'} V
                `;
            } else {
                // Default: Base Score first
                const ocText = b.cpu.canOC === 'Yes' ? `OC Potential: ${b.cpu.ocScore}` : 'Locked';
                cpuSpecs = `
                    Base Score: ${formatNumber(displayCpuScore)} | ${ocText} | ${b.cpu.socket} | ${b.cpu.cores} Cores | 
                    ${b.cpu.baseFreq || '?'} / ${b.cpu.maxFreq || '?'} MHz | 
                    ${b.cpu.voltage || '?'}/${b.cpu.maxVoltage || '?'} V
                `;
            }

            let ramHTML = '';
            if (b.ram) {
                ramHTML = `
                <div class="part-row brand-ram text-colored">
                    <div class="part-header">
                        <span class="part-label">RAM</span>
                        <span class="part-price">${formatCurrency(b.ram.price * b.ramSticks)}</span>
                    </div>
                    <div class="part-name">${b.ramSticks}x ${b.ram.name}</div>
                    <div class="part-specs">${b.ram.freq} MHz | ${b.ram.type} | Size Each: ${b.ram.size}GB | Total: ${b.ram.size * b.ramSticks}GB</div>
                </div>`;
            }

            let auxHTML = '';
            if (b.mobo) {
                auxHTML += `
                <div class="part-row brand-aux text-colored">
                    <div class="part-header">
                        <span class="part-label">Motherboard</span>
                        <span class="part-price">${formatCurrency(b.mobo.price)}</span>
                    </div>
                    <div class="part-name">${b.mobo.name}</div>
                    <div class="part-specs">${b.mobo.socket} | ${b.mobo.ramType} | ${b.mobo.size} Form Factor | PCI Slots: ${b.mobo.pciSlots}</div>
                </div>`;
            }
            if (b.psu) {
                auxHTML += `
                <div class="part-row brand-aux text-colored">
                    <div class="part-header">
                        <span class="part-label">PSU</span>
                        <span class="part-price">${formatCurrency(b.psu.price)}</span>
                    </div>
                    <div class="part-name">${b.psu.name}</div>
                    <div class="part-specs">${b.psu.watts}W | Length: ${b.psu.length}mm</div>
                </div>`;
            }

            let interactiveHTML = '';
            
            // Storage Display Logic
            if (b.storages && b.storages.length > 0) {
                let totalStoragePrice = b.storages.reduce((acc, s) => acc + s.price, 0);
                
                // Summarize storage string (Group by Name)
                const storageCounts = {};
                b.storages.forEach(s => {
                    if (!storageCounts[s.name]) storageCounts[s.name] = { count: 0, part: s };
                    storageCounts[s.name].count++;
                });

                let summaryParts = [];
                Object.values(storageCounts).forEach(item => {
                    const s = item.part;
                    const c = item.count;
                    summaryParts.push(`${c}x ${s.sizeStr} ${s.type}`);
                });

                interactiveHTML += renderInteractive('Storage', 
                    { name: "Manage Storage", price: totalStoragePrice }, 
                    buildIdx, 'storage', summaryParts.join(" | ")
                );
            } else if (document.getElementById('incStorage').checked) {
                 interactiveHTML += renderInteractive('Storage', {name: "Add Storage", price: 0}, buildIdx, 'storage', "No drives selected");
            }

            if (b.case) {
                interactiveHTML += renderInteractive('Case', b.case, buildIdx, 'cases',
                    `Max GPU: ${b.case.maxGpuLen}mm | CPU H: ${b.case.maxCpuHeight}mm | Size: ${b.case.size} | GPU Slots: ${b.case.gpuSlots} | SSD: ${b.case.ssdSlots} | HDD: ${b.case.hddSlots}`
                );
            }
            if (b.cooler) {
                interactiveHTML += renderInteractive('Cooler', b.cooler, buildIdx, 'cooler',
                    `${b.cooler.type} | ${b.cooler.type.includes('Air') ? `Height: ${b.cooler.height}mm` : `Size: ${b.cooler.size}mm`} | Flow: ${b.cooler.flow} CFM`
                );
            }
            if (b.fan) {
                interactiveHTML += renderInteractive('Case Fans (x1)', b.fan, buildIdx, 'fan',
                    `Size: ${b.fan.size}mm | Airflow: ${b.fan.flow} CFM`
                );
            }

            const html = `
            <div class="build-card" style="animation-delay:${i*0.02}s">
                <div class="card-header">
                    <div class="score-container">
                        <span class="build-number">#${start + i + 1}</span>
                        <div class="score-box">${formatNumber(b.score)}</div>
                        <div class="diff-box ${diffClass}">${sign}${Math.abs(Math.round(b.diff))}</div>
                    </div>
                    <div class="header-stats">
                        <div class="stats-row">
                            <div class="watts-box">âš¡ ${b.watts}W</div>
                            <div class="price-box">${formatCurrency(b.price)}</div>
                        </div>
                        <div class="level-box">GPU L${b.gpu.level} | CPU L${b.cpu.level}</div>
                    </div>
                    </div>
                </div>
                <div class="card-body">
                    <div class="part-row ${gpuClass} text-colored">
                        <div class="part-header">
                            <span class="part-label" style="font-size: 1.5em; font-weight: 900;">${gpuCountStr}GPU</span>
                            <span class="part-price">${formatCurrency(b.gpu.price * b.gpuCnt)}</span>
                        </div>
                        <div class="part-name">${b.gpu.name}</div>
                        <div class="part-specs">${gpuSpecs}</div>
                    </div>
                    <div class="part-row ${cpuClass} text-colored">
                        <div class="part-header">
                            <span class="part-label">CPU</span>
                            <span class="part-price">${formatCurrency(b.cpu.price)}</span>
                        </div>
                        <div class="part-name">${b.cpu.name}</div>
                        <div class="part-specs">${cpuSpecs}</div>
                    </div>
                    ${ramHTML}
                    ${auxHTML}
                    ${interactiveHTML}
                </div>
            </div>`;
            list.innerHTML += html;
        });

        const pageInfo = document.getElementById('pageInfo');
        if (!pageInfo.querySelector('input')) {
            pageInfo.innerText = `Page ${page} of ${total}`;
        }
        document.getElementById('btnPrev').disabled = (page === 1);
        document.getElementById('btnNext').disabled = (page === total || total === 0);
    }

    function renderInteractive(label, part, bIdx, type, specs) {
        let price = part.price;
        return `
        <div class="part-row interactive brand-generic" onclick="openSwapPopup('${type}', ${bIdx})">
            <button class="btn-change">${type === 'storage' ? 'Manage' : 'Change'}</button>
            <div class="part-header">
                <span class="part-label">${label}</span>
                <span class="part-price">${formatCurrency(price)}</span>
            </div>
            <div class="part-name">${part.name}</div>
            <div class="part-specs">${specs}</div>
        </div>`;
    }

    function changePage(d) {
        const total = Math.ceil(builds.length / itemsPerPage);
        const n = currentPage + d;
        if (n > 0 && n <= total) renderPage(n);
    }

    function makePageEditable() {
        const pageInfo = document.getElementById('pageInfo');
        if (pageInfo.querySelector('input')) return;
        const totalPages = Math.ceil(builds.length / itemsPerPage);
        const input = document.createElement('input');
        input.type = 'number';
        input.value = currentPage;
        input.className = 'page-jump-input';
        const save = () => {
            let val = parseInt(input.value);
            if (isNaN(val) || val < 1) val = 1;
            if (val > totalPages) val = totalPages;
            pageInfo.innerHTML = '';
            renderPage(val);
        };
        input.onblur = save;
        input.onkeydown = (e) => { if (e.key === 'Enter') input.blur(); };
        pageInfo.innerHTML = '';
        pageInfo.appendChild(input);
        input.focus();
        input.select();
    }

    // ==================== POPUP LOGIC ====================
    function openSwapPopup(type, buildIdx) {
        const build = builds[buildIdx];
        
        let original = null;
        if (type === 'fan') original = build.fan;
        else if (type === 'cases') original = build.case;
        else if (type === 'cooler') original = build.cooler;
        else if (type === 'storage') original = null; // Storage uses array logic

        currentPopupData = {
            type,
            buildIdx, 
            originalPart: original
        };

        document.getElementById('popupSearch').value = "";
        document.getElementById('popupTitle').innerText = `Swap ${type.toUpperCase()}`;
        document.getElementById('popupOverlay').style.display = 'block';
        document.getElementById('popupContainer').style.display = 'flex';
        refreshPopup();
    }

    function closePopup() {
        document.getElementById('popupOverlay').style.display = 'none';
        document.getElementById('popupContainer').style.display = 'none';
        currentPopupData = null;
    }

    function refreshPopup() {
        if (!currentPopupData) return;
        const { type, buildIdx, originalPart } = currentPopupData;
        const build = builds[buildIdx];
        const fitOnly = document.getElementById('popupFit').checked;
        const sortMode = document.getElementById('popupSort').value;
        const searchVal = document.getElementById('popupSearch').value.toLowerCase();
        
        const tbody = document.getElementById('popupTableBody');
        tbody.innerHTML = '';

        let candidates = Array.from(DB[type].values());

        if (fitOnly) {
            candidates = candidates.filter(part => checkFit(type, part, build));
        }

        if (searchVal) {
            candidates = candidates.filter(part => part.name.toLowerCase().includes(searchVal));
        }

        candidates.sort((a,b) => {
            if (sortMode === 'price_asc') return a.price - b.price;
            if (sortMode === 'price_desc') return b.price - a.price;
            
            let valA = 0;
            let valB = 0;
            if (type === 'cases') { valA = a.maxGpuLen; valB = b.maxGpuLen; } 
            else if (type === 'cooler' || type === 'fan') { valA = a.flow || 0; valB = b.flow || 0; }
            else if (type === 'storage') { valA = a.speed || 0; valB = b.speed || 0; }
            
            if (sortMode === 'perf_desc') return valB - valA;

            let scoreA = (valA / (a.price || 1));
            let scoreB = (valB / (b.price || 1));
            if (sortMode === 'val_desc') return scoreB - scoreA; 
            if (sortMode === 'val_asc') return scoreA - scoreB; 
            
            return 0;
        });

        const subset = candidates.slice(0, 100);

        subset.forEach((p, idx) => {
            let origPrice = originalPart ? originalPart.price : 0;
            let newPrice = p.price;
            
            // Special Logic for Storage Rows
            let actionBtn = "";
            let diffStr = "";
            let diffClass = "";

            if (type === 'storage') {
                const currentDrives = build.storages || [];
                const isSelected = currentDrives.some(d => d.name === p.name);
                const isSSD = (p.type === 'SSD' || p.type === 'M.2');
                
                // Constraints (Slot Limit only)
                const currentSameType = currentDrives.filter(d => (d.type === 'SSD' || d.type === 'M.2') === isSSD);
                const slotCount = isSSD ? build.case.ssdSlots : build.case.hddSlots;
                const slotsFull = currentSameType.length >= slotCount;

                // For storage popup, we show ADD/REMOVE buttons
                if (isSelected) {
                    // Count how many of this drive we have
                    const count = currentDrives.filter(d => d.name === p.name).length;
                    actionBtn = `
                        <button class="btn-select-part selected" onclick="toggleStorage('${p.name.replace(/'/g, "\\'")}', -1)">REMOVE (Has ${count})</button>
                        ${!slotsFull ? `<button class="btn-select-part" onclick="toggleStorage('${p.name.replace(/'/g, "\\'")}', 1)">ADD</button>` : ''}
                    `;
                } else if (slotsFull) {
                    actionBtn = `<button class="btn-select-part" disabled title="No Slots Available">FULL</button>`;
                } else {
                    actionBtn = `<button class="btn-select-part" onclick="toggleStorage('${p.name.replace(/'/g, "\\'")}', 1)">ADD</button>`;
                }
                
                diffStr = formatCurrency(p.price);

            } else {
                const diff = newPrice - origPrice;
                diffStr = diff > 0 ? `+${formatCurrency(diff)}` : (diff < 0 ? `-${formatCurrency(Math.abs(diff))}` : '$0.00');
                diffClass = diff > 0 ? 'val-neg' : (diff < 0 ? 'val-pos' : '');
                const safeName = p.name.replace(/'/g, "\\'");
                actionBtn = `<button class="btn-select-part" onclick="selectReplacementPart('${safeName}')">SELECT</button>`;
            }

            let details = '';
            if (type === 'cases') details = `Max GPU: ${p.maxGpuLen}mm | CPU H: ${p.maxCpuHeight}mm | Size: ${p.size} | GPU Slots: ${p.gpuSlots}`;
            if (type === 'cooler') details = `${p.type} | ${p.type.includes('Air') ? `Height: ${p.height}mm` : `Size: ${p.size}mm`} | Flow: ${p.flow}`;
            if (type === 'fan') details = `Size: ${p.size}mm | Flow: ${p.flow} CFM`;
            if (type === 'storage') details = `${p.sizeStr} | ${p.type} | Level ${p.level} | ${p.speed} MB/s`;

            const tr = document.createElement('tr');
            
            tr.innerHTML = `
                <td>${actionBtn}</td>
                <td style="font-weight:bold; color:#fff;">${p.name}</td>
                <td style="font-size:0.9em; color:#aaa;">${details}</td>
                <td class="price-red-cell">${formatCurrency(newPrice)}</td>
                <td class="${diffClass}">${diffStr}</td>
            `;
            
            tbody.appendChild(tr);
        });
    }

    window.toggleStorage = function(partName, delta) {
        if (!currentPopupData || currentPopupData.type !== 'storage') return;
        const newPart = DB['storage'].get(partName);
        const build = builds[currentPopupData.buildIdx];

        if (delta > 0) {
            // Add
            build.storages.push(newPart);
            build.price += newPart.price;
        } else {
            // Remove
            const existsIdx = build.storages.findIndex(d => d.name === partName);
            if (existsIdx > -1) {
                build.storages.splice(existsIdx, 1);
                build.price -= newPart.price;
            }
        }

        refreshPopup();
        renderPage(currentPage);
    }

    window.selectReplacementPart = function(partName) {
        if (!currentPopupData) return;
        
        const newPart = DB[currentPopupData.type].get(partName);
        if(!newPart) return;

        const { type, buildIdx, originalPart } = currentPopupData;
        const build = builds[buildIdx];

        let priceDiff = newPart.price - (originalPart ? originalPart.price : 0);
        
        if (type === 'cases') build.case = newPart;
        else if (type === 'cooler') build.cooler = newPart;
        else if (type === 'fan') build.fan = newPart;

        build.price += priceDiff;

        closePopup();
        renderPage(currentPage); 
    }

    function checkFit(type, part, build) {
        const lvl = parseInt(document.getElementById('level').value);
        if (part.level > lvl) return false;

        if (type === 'cases') {
            if (part.maxGpuLen < build.gpu.length) return false;
            if (build.mobo && !part.moboSizes.includes(build.mobo.size)) return false;
            if (build.cooler && build.cooler.type.includes('Air') &&
                part.maxCpuHeight < build.cooler.height) return false;
            if (build.psu && part.maxPsuLen > 0 && build.psu.length > part.maxPsuLen) return false;
            
            // Check Multi GPU Slot Fit
            if (build.gpuCnt > 1 && part.gpuSlots < 3) return false;

            // Check Storage Fit if we are validating a case against existing storage
            if (build.storages) {
                const ssds = build.storages.filter(s => s.type==='SSD' || s.type==='M.2').length;
                const hdds = build.storages.filter(s => s.type==='HDD').length;
                if (ssds > part.ssdSlots) return false;
                if (hdds > part.hddSlots) return false;
            }

            return true;
        }

        if (type === 'cooler') {
            if (!part.sockets.includes(build.cpu.socket)) return false;
            if (build.case) {
                if (part.type.includes('Air')) return build.case.maxCpuHeight >= part.height;
                if (part.type.includes('Liquid')) return build.case.radSizes.includes(part.size.toString());
            }
            return true;
        }

        if (type === 'fan') {
            if (!build.case) return true;
            const s120 = build.case.radSizes.includes('120');
            const s140 = build.case.radSizes.includes('140');
            if (part.size === 120 && !s120) return false;
            if (part.size === 140 && !s140) return false;
            return true;
        }

        if (type === 'storage') {
            // Simplified compatibility check (Slots & Mfg check happen in button logic)
            return true;
        }

        return true;
    }
</script>
</body>
</html>
