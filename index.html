
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PCBS2 Ultimate Pro Builder</title>
    <!-- SQLite WASM -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.min.js"></script>
    <style>
        :root {
            --bg-dark: #0f0f1e;
            --bg-panel: #1a1a2e;
            --accent: #3498db;
            --accent-hover: #2980b9;
            --highlight: #e67e22; 
            --text-main: #ecf0f1;
            --text-muted: #95a5a6;
            --border: rgba(52, 152, 219, 0.3);

            --price-red: #ff4757;
            --watt-lime: #d4e157;
            --score-blue: #00d2ff;
            --success: #2ecc71;
            --error: #e74c3c;
            --warning: #f1c40f;

            /* Brand Colors */
            --brand-amd: #d35400;
            --brand-intel: #00d2ff;
            --brand-intel-gpu: #0047AB;
            --brand-nvidia: #76b900;
            --brand-ram: #e0b0ff;
            --brand-aux: #e0b0ff;
            
            /* Dark Grey for Generic/Case */
            --brand-generic: #2c3e50; 
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0b0c15 0%, #151621 100%);
            color: var(--text-main);
            min-height: 100vh;
            padding: 20px;
            font-size: 14px;
            overflow-y: scroll;
            zoom: 90%;
        }

        .hidden { display: none !important; }
        .container { max-width: 1800px; margin: 0 auto; padding-bottom: 100px; }

        /* Loading Overlay */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 30, 0.95);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
            transition: opacity 0.5s ease;
        }
        
        .spinner {
            width: 60px;
            height: 60px;
            border: 6px solid rgba(52, 152, 219, 0.2);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        #loadingText {
            font-size: 1.5em;
            color: var(--accent);
            font-weight: bold;
            letter-spacing: 1px;
        }

        /* Header */
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            border: 1px solid var(--border);
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.1);
            position: relative;
        }

/* Add inside <style> */

.btn-revert {
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
    width: 25px;
    height: 25px;
    border-radius: 50%;
    background: var(--warning);
    color: #000;
    border: none;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    box-shadow: 0 0 5px rgba(241, 196, 15, 0.5);
    z-index: 10;
    transition: 0.2s;
}

.btn-revert:hover {
    transform: translateY(-50%) scale(1.1);
    background: #fff;
}

/* Update popup button styles */
.btn-select-part.selected {
    background: var(--brand-generic); /* Dark Grey/Blue */
    color: #ccc;
    border: 1px solid #555;
    cursor: default;
}
.btn-select-part.is-current {
    background: var(--error); /* Red for currently active part to allow deselect/revert logic */
    color: white;
    cursor: pointer;
}
.btn-select-part.revert-target {
    background: var(--highlight); /* Orange for Original part */
    color: white;
}

        header h1 {
            font-size: 2.5em;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .header-subtitle {
            font-size: 1.1em;
            color: var(--text-muted);
            margin-top: 5px;
            font-weight: 500;
        }

/* Add/Ensure this exists */
.mode-btn.active-green {
    background: rgba(46, 204, 113, 0.6) !important;
    color: white !important;
    box-shadow: inset 0 0 10px rgba(46, 204, 113, 0.3);
    border: 1px solid var(--success) !important;
}

/* Hover state for the green button when active */
.mode-btn.active-green:hover {
    background: rgba(46, 204, 113, 0.8) !important;
}

        .view-toggle-btn {
            position: absolute;
            top: 25px;
            right: 25px;
            width: 350px;
            padding: 15px;
            background: var(--bg-panel);
            border: 2px solid var(--accent);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
            text-align: center;
            white-space: normal;
            line-height: 1.4;
            z-index: 50;
        }
        .view-toggle-btn:hover { 
            background: var(--accent); 
            box-shadow: 0 0 15px var(--accent);
        }

        /* Perf Warning */
        #perfWarning {
            background: rgba(46, 204, 113, 0.15); 
            border: 1px solid var(--success);
            color: var(--text-main);
            padding: 10px 15px;
            margin: 15px auto 0 auto;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            font-weight: 500;
            max-width: 800px;
            position: relative;
        }
        #perfWarning.hidden { display: none !important; }
        
        #perfWarning span { 
            font-weight: bold; 
            color: var(--success); 
        }
        .close-warning {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5em;
            cursor: pointer;
            color: var(--text-muted);
        }
        .close-warning:hover { color: white; }

        /* Controls */
        .controls-wrapper {
            background: var(--bg-panel);
            padding: 30px;
            border-radius: 12px;
            border: 1px solid var(--border);
            margin-bottom: 30px;
            opacity: 0.6;
            pointer-events: none;
            transition: 0.3s;
        }
        .controls-wrapper.active { opacity: 1; pointer-events: all; }

        .section-header {
            font-size: 1.3em;
            color: var(--accent);
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Benchmark Toggle */
        .benchmark-toggle {
            display: flex;
            gap: 0;
            margin-bottom: 25px;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid var(--border);
            width: fit-content;
        }
        .mode-btn {
            padding: 12px 30px;
            font-size: 1.1em;
            font-weight: bold;
            background: #0f0f1e;
            color: var(--text-muted);
            border: none;
            cursor: pointer;
            transition: 0.2s;
            border-right: 1px solid var(--border);
        }
        .mode-btn:last-child { border-right: none; }
        .mode-btn:hover { background: rgba(230, 126, 34, 0.2); color: white; }
        
        .mode-btn.active { 
            background: var(--highlight); 
            color: white; 
            border-color: var(--highlight);
        }

        /* Input Grid */
        .input-grid, .ram-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
            align-items: flex-end; 
        }
        
        .input-group { 
            display: flex; 
            flex-direction: column; 
            width: 100%;
        }

        .input-group label {
            margin-bottom: 8px;
            color: var(--text-muted);
            font-size: 0.9em;
            font-weight: 600;
            line-height: 1.2;
        }

        .input-group input, 
        .input-group select,
        .multi-select-display,
        .checkbox-container {
            height: 48px;
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border);
            color: white;
            padding: 0 12px;
            border-radius: 6px;
            font-size: 1em;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            align-items: center; 
        }

        .input-group input, 
        .input-group select {
            display: block; 
            padding-top: 10px;
            padding-bottom: 10px;
        }

        .input-group input:focus, 
        .input-group select:focus,
        .multi-select-display:hover,
        .checkbox-container:hover {
            border-color: var(--accent);
            outline: none;
            background: rgba(0,0,0,0.5);
        }

        /* Checkboxes */
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }
        
        .input-group > div[style*="display:flex"] .checkbox-container {
            height: 48px;
            white-space: nowrap;
        }

        .checkbox-container input {
            width: 20px;
            height: 20px;
            margin: 0;
            accent-color: var(--accent);
            cursor: pointer;
            border: none;
            background: transparent;
        }
        
        .checkbox-container label {
            margin: 0;
            cursor: pointer;
            font-weight: 600;
            font-size: 1em;
            color: #fff;
        }

        /* Multi-Select Dropdowns */
        .multi-select-container { position: relative; width: 100%; }
        
        .multi-select-display {
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            user-select: none;
            padding-right: 30px; 
            position: relative;
        }
        
        .multi-select-display:after {
            content: 'â–¼';
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
            font-size: 0.8em;
        }

        .multi-dropdown {
            position: absolute;
            top: 105%;
            left: 0;
            width: 100%;
            background: #1e1e2f;
            border: 1px solid var(--border);
            border-radius: 6px;
            z-index: 1000;
            display: none;
            box-shadow: 0 10px 25px rgba(0,0,0,0.8);
            overflow: hidden;
            flex-direction: column;
        }
        .multi-dropdown.show { display: flex; max-height: 500px; }

        .quick-filter-bar {
            padding: 8px;
            background: #151525;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .filter-btn {
            padding: 5px 10px;
            font-size: 0.85em;
            background: transparent;
            border: 1px solid #555;
            color: #ccc;
            border-radius: 4px;
            cursor: pointer;
            transition: 0.2s;
            font-weight: 600;
        }
        .filter-btn:hover { color: #fff; }

        .btn-clear { border-color: var(--brand-generic); color: var(--error); }
        .btn-clear:hover { background: var(--brand-generic); color: white; }

        .btn-amd { border-color: var(--brand-amd); color: var(--brand-amd); }
        .btn-amd:hover { background: var(--brand-amd); color: white; }

        .btn-intel { border-color: var(--brand-intel); color: var(--brand-intel); }
        .btn-intel:hover { background: var(--brand-intel); color: white; }

        .btn-nvidia { border-color: var(--brand-nvidia); color: var(--brand-nvidia); }
        .btn-nvidia:hover { background: var(--brand-nvidia); color: white; }

        .btn-size-filter {
            background: rgba(52, 152, 219, 0.1);
            border-color: var(--accent);
            color: var(--text-muted);
        }
        .btn-size-filter:hover {
            background: var(--accent);
            color: white;
        }

        .dropdown-search-container {
            padding: 8px;
            background: #151525;
            border-bottom: 1px solid var(--border);
        }
        .dropdown-search {
            width: 100%;
            padding: 8px;
            font-size: 0.9em;
            border: 1px solid #444;
            background: #0f0f1e;
            color: white;
            border-radius: 4px;
        }
        .dropdown-list-container {
            overflow-y: auto;
            max-height: 300px;
        }
        .multi-option {
            padding: 8px 12px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            cursor: pointer;
            display: flex;
            align-items: center;
            transition: 0.1s;
            user-select: none;
            justify-content: space-between;
        }
        .multi-option:hover { background: rgba(52, 152, 219, 0.2); }
        .multi-option.selected { background: rgba(52, 152, 219, 0.4); }
        .multi-option.selected .cb-custom {
            background: var(--accent);
            border-color: var(--accent);
        }
        .multi-option.selected .cb-custom:after {
            content: 'âœ“';
            font-size: 12px;
            color: white;
            font-weight: bold;
        }
        .option-left { display: flex; align-items: center; flex: 1; overflow: hidden; }

        .cb-custom {
            width: 16px;
            height: 16px;
            border: 1px solid var(--text-muted);
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .qty-controls {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            padding: 2px;
        }
        .qty-btn {
            background: #444;
            border: none;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 2px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        .qty-btn:hover { background: var(--accent); }
        .qty-val {
            font-weight: bold;
            color: var(--score-blue);
            min-width: 20px;
            text-align: center;
        }

        .btn-generate {
            width: 100%;
            padding: 18px;
            font-size: 1.5em;
            font-weight: 800;
            background: linear-gradient(90deg, #2980b9, var(--accent));
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 20px;
        }
        .btn-generate:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(52, 152, 219, 0.3);
        }
        .btn-generate:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }

        /* Results Meta Bar */
        .results-meta {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* Changed for scan report */
            background: var(--bg-panel);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border);
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
            position: relative;
        }

        .meta-left-col {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .result-count {
            font-size: 1.4em;
            font-weight: bold;
            color: var(--text-main);
        }
        
        /* Scan Report Text */
        .scan-report {
            font-size: 0.9em;
            color: #e74c3c; /* Warning red */
            font-weight: bold;
            font-family: 'Consolas', monospace;
            white-space: pre-wrap;
            margin-bottom: 5px;
        }

        .sort-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .sort-select {
            padding: 15px 20px;
            background: #0f0f1e;
            border: 1px solid var(--accent);
            color: white;
            border-radius: 4px;
            font-weight: bold;
            font-size: 1.1em;
            min-width: 320px;
            height: 60px;
            cursor: pointer;
        }

        .min-score-container {
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(52, 152, 219, 0.15);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid var(--border);
            height: 60px;
            position: relative;
        }
        .min-score-label {
            font-size: 1.2em;
            font-weight: bold;
            color: #4169E1;
            white-space: nowrap;
        }
        #minScoreInput {
            width: 150px;
            font-size: 1.2em;
            padding: 10px;
            height: 40px;
            background: #0f0f1e;
            border: 1px solid var(--accent);
            font-weight: bold;
            color: #fff;
            border-radius: 4px;
        }

        .score-range-text {
            color: #95a5a6;
            font-weight: 500;
            font-size: 1.4em;
            margin-left: 20px;
            white-space: nowrap;
            display: inline-block;
        }

        /* TOGGLE SWITCH STYLES */
        .toggle-wrapper {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .toggle-label {
            font-size: 0.9em;
            color: var(--text-muted);
            font-weight: bold;
            text-align: center;
        }
        .toggle-btns {
            display: flex;
            border: 1px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
            height: 40px; 
        }
        .toggle-btn {
            background: rgba(0,0,0,0.3);
            border: none;
            color: #777;
            padding: 0 15px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
            flex: 1;
        }
        .toggle-btn.active {
            background: rgba(52, 152, 219, 0.5); /* Semi-transparent blue */
            color: white;
            box-shadow: inset 0 0 10px rgba(52, 152, 219, 0.2);
        }
        /* New GREEN Active state */
        .toggle-btn.active-green {
            background: rgba(46, 204, 113, 0.6) !important; /* Green */
            color: white;
            box-shadow: inset 0 0 10px rgba(46, 204, 113, 0.3);
            border: 1px solid var(--success);
        }

        .toggle-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }


        /* Build Cards */
        .build-card {
            background: var(--bg-panel);
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
            animation: slideIn 0.4s ease-out forwards;
            opacity: 0;
            border-left: 6px solid #444;
        }
        .build-card:hover {
            border-color: var(--accent);
            box-shadow: 0 5px 25px rgba(0,0,0,0.5);
        }

        .card-header {
            background: rgba(0,0,0,0.3);
            padding: 15px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .score-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .build-number {
            color: #666;
            font-size: 0.9em;
            width: 40px;
        }
        .score-box {
            font-size: 2.2em;
            font-weight: 900;
            color: #fff;
            line-height: 1;
        }
        .diff-box {
            font-size: 1.4em;
            font-weight: bold;
            margin-left: 10px;
        }
        .diff-pos { color: var(--success); }
        .diff-neg { color: var(--error); }

       .header-stats {
            text-align: right;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        
        .stats-row {
            display: flex;
            align-items: center;
            gap: 15px; 
        }

        .price-box {
            font-size: 1.8em;
            color: var(--price-red);
            font-weight: bold;
        }

        .watts-box {
            font-size: 1.8em;
            color: var(--watt-lime);
            font-weight: 800;
            margin-top: 0; 
        }

        .level-box {
            font-size: 0.95em;
            color: #cd853f;
            font-weight: bold;
            margin-top: 5px;
        }


        .card-body {
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        /* Part Rows */
        .part-row {
            display: flex;
            flex-direction: column;
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
            padding: 12px;
            border-left: 4px solid #555;
            position: relative;
            --row-color: #fff;
    padding-left: 45px; /* Make room for the revert button on the left */

        }

        .part-row.brand-amd { border-left-color: var(--brand-amd); --row-color: var(--brand-amd); }
        .part-row.brand-intel { border-left-color: var(--brand-intel); --row-color: var(--brand-intel); }
        .part-row.brand-intel-gpu { border-left-color: var(--brand-intel-gpu); --row-color: var(--brand-intel-gpu); }
        .part-row.brand-nvidia { border-left-color: var(--brand-nvidia); --row-color: var(--brand-nvidia); }
        .part-row.brand-ram { border-left-color: var(--brand-ram); --row-color: var(--brand-ram); }
        .part-row.brand-aux { border-left-color: var(--brand-aux); --row-color: var(--brand-aux); }
        
        .part-row.brand-generic {
            background: var(--brand-generic);
            border-left-color: #7f8c8d;
        }
        .part-row.brand-generic .part-label,
        .part-row.brand-generic .part-name,
        .part-row.brand-generic .part-specs,
        .part-row.brand-generic .part-price {
            color: #ecf0f1 !important;
        }

        .part-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .part-label {
            font-size: 0.85em;
            text-transform: uppercase;
            color: var(--text-muted);
            font-weight: bold;
        }
        .part-price {
            color: var(--price-red);
            font-weight: 600;
            font-size: 1.25em;
        }
        .part-name {
            font-size: 1.35em;
            font-weight: 800;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: #fff; 
        }

        .part-row.text-colored .part-label,
        .part-row.text-colored .part-price,
        .part-row.text-colored .part-name,
        .part-row.text-colored .part-specs {
            color: var(--row-color) !important;
        }

        .part-specs {
            font-size: 1.25em;
            font-weight: 600;
            line-height: 1.4;
            margin-top: 5px;
            padding: 2px 0;
            color: #bdc3c7;
        }

        /* Interactive Parts */
        .part-row.interactive {
            cursor: pointer;
            transition: 0.2s;
            border: 1px dashed rgba(255,255,255,0.1);
        }
        .part-row.interactive:hover {
            background: rgba(52, 152, 219, 0.1);
            border-color: var(--accent);
        }

        .btn-change {
            position: absolute;
            right: 10px;
            top: 10px;
            background: var(--accent);
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
            opacity: 0;
            transition: 0.2s;
            cursor: pointer;
        }
        .part-row.interactive:hover .btn-change { opacity: 1; }

        /* Popup Overlay */
        #popupOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 9998;
            display: none;
            backdrop-filter: blur(5px);
        }
        #popupContainer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 95%;
            max-width: 1200px;
            height: 90vh;
            background: #151525;
            border: 2px solid var(--accent);
            border-radius: 12px;
            z-index: 9999;
            display: none;
            flex-direction: column;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        .popup-header {
            padding: 20px;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .popup-title {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--text-main);
        }
        .popup-close {
            font-size: 2em;
            cursor: pointer;
            color: var(--text-muted);
            line-height: 0.5;
        }
        .popup-close:hover { color: var(--error); }

        .popup-filters {
            padding: 15px;
            display: flex;
            gap: 15px;
            background: #0f0f1e;
            border-bottom: 1px solid var(--border);
            align-items: center;
            flex-wrap: wrap;
        }

        #popupSearch {
            padding: 12px 15px;
            background: #0b0c15;
            border: 1px solid var(--accent);
            color: white;
            border-radius: 4px;
            font-size: 1.1em;
            width: 300px;
            margin-left: 20px;
        }

        #popupSort {
            width: 250px;
            padding: 12px 15px;
            height: 50px;
            font-size: 1.1em;
            background: #0f0f1e;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
        }

        .popup-body {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        .popup-table {
            width: 100%;
            border-collapse: collapse;
        }
        .popup-table th {
            text-align: left;
            padding: 15px;
            background: #202030;
            color: #ccc;
            position: sticky;
            top: 0;
            z-index: 2;
        }
        .popup-table td {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            color: #ddd;
            vertical-align: middle;
        }
        .popup-table tr:hover { background: rgba(255,255,255,0.05); }

        .price-red-cell {
            color: var(--price-red) !important;
            font-weight: bold;
            font-size: 1.1em;
        }

        .val-pos {
            color: var(--success);
            font-weight: bold;
        }
        .val-neg {
            color: var(--error);
            font-weight: bold;
        }
        
        .btn-select-part {
            background: var(--success);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
        }
        .btn-select-part.selected {
            background: var(--error);
            content: "REMOVE";
        }
        .btn-select-part:hover {
            transform: scale(1.05);
        }
        .btn-select-part:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 40px;
            padding: 20px;
            display: none;
            align-items: center;
        }
        .page-btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .page-btn:disabled {
            background: #444;
            cursor: not-allowed;
            opacity: 0.5;
        }
        .page-info {
            color: white;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 4px;
        }
        .page-jump-input {
            width: 80px;
            padding: 5px;
            background: #0f0f1e;
            border: 1px solid var(--accent);
            color: white;
            text-align: center;
            font-size: 1.1em;
            border-radius: 4px;
        }

        #multiRam .multi-select-display {
            font-size: 1.4em; 
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* DATA VIEWER STYLES */
        .viewer-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: var(--bg-panel);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        .v-tab-btn {
            padding: 10px 20px;
            background: #0f0f1e;
            color: var(--text-muted);
            border: 1px solid #444;
            cursor: pointer;
            font-weight: bold;
            border-radius: 4px;
            flex: 1;
        }
        .v-tab-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        .data-list-row {
            background: rgba(255,255,255,0.03);
            margin-bottom: 8px;
            padding: 15px;
            border-left: 4px solid #555;
            word-wrap: break-word;
            white-space: normal;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.6;
        }
        .data-list-row:hover { background: rgba(255,255,255,0.1); }
        .data-list-row.brand-amd { border-left-color: var(--brand-amd); }
        .data-list-row.brand-intel { border-left-color: var(--brand-intel); }
        .data-list-row.brand-nvidia { border-left-color: var(--brand-nvidia); }
        
        .item-name-list {
            display: block;
            font-weight: bold;
            font-size: 1.1em;
            color: var(--accent);
            margin-bottom: 4px;
        }
        .raw-string {
            color: #ddd;
            line-height: 1.5;
        }

        @media (max-width: 600px) {
            .card-body { grid-template-columns: 1fr; }
            .card-header { flex-direction: column; gap: 15px; }
            .header-stats { text-align: left; align-items: flex-start; }
            .results-meta { flex-direction: column; align-items: flex-start; }
            header h1 { font-size: 1.8em; }
            .view-toggle-btn { position: relative; top: 0; right: 0; margin-top: 10px; width: 100%; }
        }

        @media (max-width: 900px) {
            .view-toggle-btn {
                position: relative;
                top: 0;
                right: 0;
                width: 100%;
                margin-top: 20px;
            }
        }

    </style>
</head>
<body>

<!-- Loading Screen -->
<div id="loadingOverlay">
    <div class="spinner"></div>
    <div id="loadingText">Connecting to Database...</div>
</div>

<!-- Popup Overlay for Part Swapping -->
<div id="popupOverlay" onclick="closePopup()"></div>
<div id="popupContainer">
    <div class="popup-header">
        <div class="popup-title" id="popupTitle">Select Replacement Part</div>
        <div class="popup-close" onclick="closePopup()">&times;</div>
    </div>
    <div class="popup-filters">
        <div class="checkbox-container">
            <input type="checkbox" id="popupFit" checked onchange="refreshPopup()">
            <label for="popupFit">Show Only Fitting Parts</label>
        </div>
        
        <input type="text" id="popupSearch" placeholder="ðŸ” Search part by name..." oninput="refreshPopup()">

        <div style="flex:1;"></div>
        <label>Sort By:</label>
        <select id="popupSort" onchange="refreshPopup()">
            <option value="price_asc">Lowest Price</option>
            <option value="price_desc">Highest Price</option>
            <option value="perf_desc">Highest Performance</option>
            <option value="val_desc">Most Overperforming (Best Value)</option>
            <option value="val_asc">Most Underperforming (Worst Value)</option>
        </select>
    </div>
    <div class="popup-body">
        <table class="popup-table">
            <thead>
                <tr>
                    <th style="width:100px;">Action</th>
                    <th>Part Name</th>
                    <th>Specs</th>
                    <th>Price</th>
                    <th>Cost Diff</th>
                </tr>
            </thead>
            <tbody id="popupTableBody"></tbody>
        </table>
    </div>
</div>

<div class="container">
    <header>
        <h1>PCBS2 Ultimate Builder</h1>
        <div class="header-subtitle">contact timmy2131_ on discord for bug reports</div>
        <button class="view-toggle-btn" onclick="toggleView()" id="mainViewToggle">
            <span style="font-size:1.4em; display:block; margin-bottom:5px;">Data Viewer</span>
            <span style="font-size:1.1em; font-weight:normal; color:#ccc;">click this box to swap to the data info page where u can know right OC values, more info about parts, and countless more stuff</span>
        </button>        
        <!-- Performance Tip -->
        <div id="perfWarning" class="hidden">
            <span>ðŸ’¡ PRO TIP:</span> 
            If you don't specify preferred RAM brand, size, frequency, or other component filters, the generated results pool could become massive.
            <div class="close-warning" onclick="dismissWarning()">&times;</div>
        </div>
    </header>

    <!-- CALCULATOR VIEW -->
    <div id="calculatorView" style="display: block;">
        <div class="controls-wrapper" id="controls">
<!-- REPLACEMENT HTML START -->
<div style="display: flex; gap: 20px; align-items: flex-end; margin-bottom: 25px;">
    <!-- Benchmark Type Buttons -->
    <div>
        <div class="benchmark-toggle" style="margin-bottom: 0;">
            <button id="btnTS" class="mode-btn active" onclick="setMode('TS')">Time Spy (Standard)</button>
            <button id="btnTSX" class="mode-btn" onclick="setMode('TSX')">Time Spy Extreme (4K)</button>
        </div>
    </div>

<!-- Performance Mode Button (Defaulted to OFF) -->
    <div style="display: flex; flex-direction: column; align-items: center;">
        <span style="font-size: 0.85em; color: var(--text-muted); font-weight: bold; margin-bottom: 5px;">
            Performance Mode To Speed up Scan (Limits Ram Frequency)
        </span>
        <button id="btnPerfMode" class="mode-btn" 
                style="border-radius: 6px; border: 1px solid var(--border); width: 100%; padding: 12px 30px;" 
                onclick="togglePerfMode()">
            OFF
        </button>
    </div>
</div>
<!-- REPLACEMENT HTML END -->

            <!-- REPLACE THE FIRST .input-grid INSIDE "Benchmarking & Goals" WITH THIS -->
<div class="input-grid">
    <div class="input-group">
        <label>Budget ($)</label>
        <input type="text" id="budget" value="3,500">
    </div>
    
<div class="input-group">
        <label>Min 3DMark Score</label>
        <input type="text" id="minTargetScore" value="25,000">
    </div>

    <div class="input-group">
        <label>Max 3DMark Score</label>
        <input type="text" id="targetScore" value="30,000">
    </div>

    <div class="input-group">
        <label>GPU Count</label>
        <div id="multiGpuCount" class="multi-select-container">
            <div class="multi-select-display" onclick="toggleDropdown('gpuCountDropdown')">Any</div>
            <div id="gpuCountDropdown" class="multi-dropdown">
                <div class="quick-filter-bar">
                    <button class="filter-btn btn-clear" onclick="clearFilter('gpuCount')">Clear</button>
                </div>
                <div class="dropdown-list-container" id="gpuCountListContainer"></div>
            </div>
        </div>
    </div>
    <div class="input-group">
        <label>Career Level</label>
        <input type="number" id="level" value="30" min="1" oninput="refreshDropdowns()">
    </div>

    <!-- REMOVED resLimit input, Moved Results Per Page here -->
    <div class="input-group">
        <label>Results Per Page</label>
        <input type="number" id="resultsPerPage" value="100" min="1" max="1000">
    </div>
</div>

            <div class="section-header">2. RAM Configuration</div>
            <div class="ram-grid">
                <div class="input-group">
                    <label>Include RAM</label>
                    <div class="checkbox-container">
                        <input type="checkbox" id="incRam" checked>
                        <label for="incRam">Suggest RAM</label>
                    </div>
                </div>

                <div class="input-group">
                    <label>Optimization</label>
                    <div class="checkbox-container">
                        <input type="checkbox" id="ramPerfMode" checked>
                        <label for="ramPerfMode">RAM Perf Mode</label>
                    </div>
                </div>

<!-- FIND THIS SECTION -->
<div class="input-group">
    <label>Stick Count</label>
    <select id="ramSticks">
        <option value="0" selected>Any</option>
        <option value="1">1 Stick</option>
        <option value="2">2 Sticks</option>
        <option value="3">3 Sticks</option> <!-- ADD THIS LINE -->
        <option value="4">4 Sticks</option>
    </select>
</div>
                
                <div class="input-group">
                    <label>Ram Stick Size</label>
                    <div id="multiRamSize" class="multi-select-container">
                        <div class="multi-select-display" onclick="toggleDropdown('ramSizeDropdown')">Any</div>
                        <div id="ramSizeDropdown" class="multi-dropdown">
                            <div class="quick-filter-bar">
                                <button class="filter-btn btn-clear" onclick="clearFilter('ramSizes')">Clear</button>
                            </div>
                            <div class="dropdown-list-container" id="ramSizeListContainer"></div>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label>Target Total Capacity</label>
                    <input type="number" id="targetTotalRam" placeholder="e.g. 128">
                </div>

                <div class="input-group">
                    <label>RAM Manufacturer</label>
                    <div id="multiRamMfgr" class="multi-select-container">
                        <div class="multi-select-display" onclick="toggleDropdown('ramMfgrDropdown')">Any</div>
                        <div id="ramMfgrDropdown" class="multi-dropdown">
                            <div class="quick-filter-bar">
                                <button class="filter-btn btn-clear" onclick="clearFilter('ramMfgrs')">Clear</button>
                            </div>
                            <div class="dropdown-list-container" id="ramMfgrListContainer"></div>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label>RAM Frequency</label>
                    <div id="multiRamFreq" class="multi-select-container">
                        <div class="multi-select-display" onclick="toggleDropdown('ramFreqDropdown')">Any</div>
                        <div id="ramFreqDropdown" class="multi-dropdown">
                            <div class="quick-filter-bar">
                                <button class="filter-btn btn-clear" onclick="clearFilter('ramFreqs')">Clear</button>
                            </div>
                            <div class="dropdown-list-container" id="ramFreqListContainer"></div>
                        </div>
                    </div>
                </div>

                <div class="input-group" style="grid-column: 1 / -1;">
                    <label>Specific RAM Model(s)</label>
                    <div id="multiRam" class="multi-select-container">
                        <div class="multi-select-display" onclick="toggleDropdown('ramDropdown')">Any</div>
                        <div id="ramDropdown" class="multi-dropdown">
                            <div class="quick-filter-bar">
                                <button class="filter-btn btn-clear" onclick="clearFilter('ramNames')">Clear</button>
                            </div>
                            <div class="dropdown-search-container">
                                <input type="text" class="dropdown-search" placeholder="Filter RAM..." oninput="filterDropdownList(this)">
                            </div>
                            <div class="dropdown-list-container" id="ramListContainer"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section-header">3. Additional Components</div>
            <div class="input-grid">
                <div class="checkbox-container">
                    <input type="checkbox" id="incMobo" checked> 
                    <label for="incMobo">Motherboard</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="incCase" checked>
                    <label for="incCase">Case</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="incCooler">
                    <label for="incCooler">CPU Cooler</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="incPsu" checked>
                    <label for="incPsu">PSU</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="incFans"> 
                    <label for="incFans">Case Fans (x1)</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="incStorage"> 
                    <label for="incStorage">Include Storage</label>
                </div>
            </div>
            
            <div class="section-header">4. Component Filters</div>
            <div class="input-grid">
                <!-- Filters here (CPU Socket, Models, etc.) -->
                <div class="input-group">
                    <label>CPU Socket (Shift/Ctrl Click)</label>
                    <div id="multiSocket" class="multi-select-container">
                        <div class="multi-select-display" onclick="toggleDropdown('socketDropdown')">Any</div>
                        <div id="socketDropdown" class="multi-dropdown">
                            <div class="quick-filter-bar">
                                <button class="filter-btn btn-clear" onclick="clearFilter('socket')">Clear</button>
                                <button class="filter-btn btn-amd" onclick="applyQuickFilter('socket', 'AMD')">Add AMD</button>
                                <button class="filter-btn btn-intel" onclick="applyQuickFilter('socket', 'Intel')">Add Intel</button>
                            </div>
                            <div class="dropdown-list-container" id="socketListContainer"></div>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label>Specific CPU Model(s)</label>
                    <div id="multiCpu" class="multi-select-container">
                        <div class="multi-select-display" onclick="toggleDropdown('cpuDropdown')">Any</div>
                        <div id="cpuDropdown" class="multi-dropdown">
                            <div class="quick-filter-bar">
                                <button class="filter-btn btn-clear" onclick="clearFilter('cpuNames')">Clear</button>
                                <button class="filter-btn btn-amd" onclick="applyQuickFilter('cpuNames', 'AMD')">Add AMD</button>
                                <button class="filter-btn btn-intel" onclick="applyQuickFilter('cpuNames', 'Intel')">Add Intel</button>
                            </div>
                            <div class="dropdown-search-container">
                                <input type="text" class="dropdown-search" placeholder="Filter CPUs..." oninput="filterDropdownList(this)">
                            </div>
                            <div class="dropdown-list-container" id="cpuListContainer"></div>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label>Specific GPU Model(s)</label>
                    <div id="multiGpu" class="multi-select-container">
                        <div class="multi-select-display" onclick="toggleDropdown('gpuDropdown')">Any</div>
                        <div id="gpuDropdown" class="multi-dropdown">
                            <div class="quick-filter-bar">
                                <button class="filter-btn btn-clear" onclick="clearFilter('gpuNames')">Clear</button>
                                <button class="filter-btn btn-nvidia" onclick="applyQuickFilter('gpuNames', 'NVIDIA')">Add NVIDIA</button>
                                <button class="filter-btn btn-amd" onclick="applyQuickFilter('gpuNames', 'AMD')">Add AMD</button>
                                <button class="filter-btn btn-intel" onclick="applyQuickFilter('gpuNames', 'Intel')">Add Intel</button>
                            </div>
                            <div class="dropdown-search-container">
                                <input type="text" class="dropdown-search" placeholder="Filter GPUs..." oninput="filterDropdownList(this)">
                            </div>
                            <div class="dropdown-list-container" id="gpuListContainer"></div>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label>Target VRAM</label>
                    <div id="multiVram" class="multi-select-container">
                        <div class="multi-select-display" onclick="toggleDropdown('vramDropdown')">Any</div>
                        <div id="vramDropdown" class="multi-dropdown">
                            <div class="quick-filter-bar">
                                <button class="filter-btn btn-clear" onclick="clearFilter('vram')">Clear Selection</button>
                            </div>
                            <div class="dropdown-list-container" id="vramListContainer"></div>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label>GPU Length</label>
                    <div id="multiLength" class="multi-select-container">
                        <div class="multi-select-display" onclick="toggleDropdown('lengthDropdown')">Any</div>
                        <div id="lengthDropdown" class="multi-dropdown">
                            <div class="quick-filter-bar">
                                <button class="filter-btn btn-clear" onclick="clearFilter('length')">Clear Selection</button>
                            </div>
                            <div class="dropdown-list-container" id="lengthListContainer"></div>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label>Specific Motherboard(s)</label>
                    <div id="multiMobo" class="multi-select-container">
                        <div class="multi-select-display" onclick="toggleDropdown('moboDropdown')">Any</div>
                        <div id="moboDropdown" class="multi-dropdown">
                            <div class="quick-filter-bar">
                                <button class="filter-btn btn-clear" onclick="clearFilter('moboNames')">Clear</button>
                            </div>
                            <div class="dropdown-search-container">
                                <input type="text" class="dropdown-search" placeholder="Filter Motherboards..." oninput="filterDropdownList(this)">
                            </div>
                            <div class="dropdown-list-container" id="moboListContainer"></div>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label>Specific Case(s)</label>
                    <div id="multiCase" class="multi-select-container">
                        <div class="multi-select-display" onclick="toggleDropdown('caseDropdown')">Any</div>
                        <div id="caseDropdown" class="multi-dropdown">
                            <div class="quick-filter-bar">
                                <button class="filter-btn btn-clear" onclick="clearFilter('caseNames')">Clear</button>
                            </div>
                            <div class="dropdown-search-container">
                                <input type="text" class="dropdown-search" placeholder="Filter Cases..." oninput="filterDropdownList(this)">
                            </div>
                            <div class="dropdown-list-container" id="caseListContainer"></div>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label>Specific SSD (Quantity)</label>
                    <div id="multiSSD" class="multi-select-container">
                        <div class="multi-select-display" onclick="toggleDropdown('ssdDropdown')">Any</div>
                        <div id="ssdDropdown" class="multi-dropdown">
                            <div class="quick-filter-bar" id="ssdQuickFilter">
                                <button class="filter-btn btn-clear" onclick="clearFilter('ssdNames')">Clear / Show All</button>
                            </div>
                            <div class="dropdown-search-container">
                                <input type="text" class="dropdown-search" placeholder="Filter SSDs..." oninput="filterDropdownList(this)">
                            </div>
                            <div class="dropdown-list-container" id="ssdListContainer"></div>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label>Specific HDD (Quantity)</label>
                    <div id="multiHDD" class="multi-select-container">
                        <div class="multi-select-display" onclick="toggleDropdown('hddDropdown')">Any</div>
                        <div id="hddDropdown" class="multi-dropdown">
                            <div class="quick-filter-bar" id="hddQuickFilter">
                                <button class="filter-btn btn-clear" onclick="clearFilter('hddNames')">Clear / Show All</button>
                            </div>
                            <div class="dropdown-search-container">
                                <input type="text" class="dropdown-search" placeholder="Filter HDDs..." oninput="filterDropdownList(this)">
                            </div>
                            <div class="dropdown-list-container" id="hddListContainer"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section-header">5. Power Constraints</div>
            <div class="input-grid">
                <div class="input-group">
                    <label>Max Total Watts</label>
                    <input type="number" id="maxTotalWatts" placeholder="No Limit">
                </div>
                <div class="input-group">
                    <label>Max CPU Watts</label>
                    <input type="number" id="maxCpuWatts" placeholder="No Limit">
                </div>
                <div class="input-group">
                    <label>Max GPU Watts</label>
                    <input type="number" id="maxGpuWatts" placeholder="No Limit">
                </div>
                <div class="input-group">
                    <label>Extra Watts Buffer (OC Suggestion: ~50)</label>
                    <input type="number" id="extraWatts" value="0">
                </div>
            </div>
            
            <button class="btn-generate" id="generateBtn" onclick="generateBuilds()">GENERATE BUILDS</button>
        </div>

        <!-- Results Meta Bar -->
        <div class="results-meta">
            <div class="meta-left-col">
                <div id="scanStatus" class="scan-report"></div>
                <div style="display: flex; align-items: center;">
                    <div class="result-count" id="resCount">Ready</div>
                    <div class="score-range-text" id="scoreRangeDisplay"></div>
                </div>
            </div>
            
            <div class="sort-controls">
                <!-- NEW TOGGLE SWITCHES -->
                <div class="toggle-wrapper">
                    <div class="toggle-label">CPU OC</div>
                    <div class="toggle-btns">
                        <button id="btnOC_Off" class="toggle-btn active" onclick="setToggle('oc', false)">OFF</button>
                        <button id="btnOC_On" class="toggle-btn" onclick="setToggle('oc', true)">ON</button>
                    </div>
                </div>

<div class="toggle-wrapper">
                    <div class="toggle-label">RAM XMP</div>
                    <div class="toggle-btns">
                        <button id="btnXMP_Off" class="toggle-btn" onclick="setToggle('xmp', false)">OFF</button>
                        <button id="btnXMP_On" class="toggle-btn active active-green" onclick="setToggle('xmp', true)">ON</button>
                    </div>
                </div>

                <label style="margin-left: 10px;">Sort By:</label>
                <select id="mainSort" class="sort-select" onchange="renderPage(1)">
                    <option value="diff">Closest to Target Score</option>
                    <option value="gpu_score">Highest Individual GPU Score</option>
                    <option value="cpu_score">Highest Individual CPU Score</option>
                    <option value="score_desc">Highest Total Score</option>
                    <option value="score_asc">Lowest Total Score</option>
                    <option value="price_asc">Lowest Price</option>
                    <option value="price_desc">Highest Price</option>
                    <option value="value_desc">Most Overperforming (Best Value)</option>
                    <option value="value_asc">Most Underperforming (Worst Value)</option>
                </select>

                <div class="min-score-container">
                    <label class="min-score-label">Min 3D Score (press enter):</label>
                    <input type="text" id="minScoreInput" placeholder="0" onchange="generateBuilds()">
                </div>
            </div>
        </div>


        <div id="resultsList"></div>

        <div class="pagination" id="pagination">
            <button class="page-btn" id="btnPrev" onclick="changePage(-1)">Previous</button>
            <div class="page-info-container" style="flex:1; display:flex; justify-content:center;">
                <span class="page-info" id="pageInfo" onclick="makePageEditable()" title="Click to jump to page">Page 1 of 1</span>
            </div>
            <button class="page-btn" id="btnNext" onclick="changePage(1)">Next</button>
        </div>
    </div>

    <!-- REPLACE THE ENTIRE <div id="dataView"> SECTION WITH THIS -->
<div id="dataView" style="display: none;">
    <div class="viewer-tabs">
        <button class="v-tab-btn active" onclick="switchDataTab('gpu')">GPUs</button>
        <button class="v-tab-btn" onclick="switchDataTab('cpu')">CPUs</button>
    </div>
    
    <div style="display: flex; gap: 15px; margin-bottom: 20px;">
        <input type="text" id="dataSearchBox" class="dropdown-search" style="flex: 2; padding:15px; font-size:1.1em;" placeholder="Type to filter components list..." oninput="filterDataList()">
        
        <select id="dataViewSort" class="dropdown-search" style="flex: 1; padding: 15px; font-size: 1.1em; cursor: pointer;" onchange="renderDataList()">
            <option value="score_desc">Highest Score</option>
            <option value="score_asc">Lowest Score</option>
            <option value="price_desc">Highest Price</option>
            <option value="price_asc">Lowest Price</option>
            <option value="val_desc">Most Overperforming</option>
            <option value="val_asc">Most Underperforming</option>
        </select>
    </div>

    <div id="dataViewListContainer"></div>
</div>

<script>
    const DB = { 
        cpu: new Map(), 
        gpu: new Map(), 
        ram: new Map(), 
        mobo: new Map(), 
        cases: new Map(), 
        psu: new Map(), 
        cooler: new Map(), 
        fan: new Map(),
        storage: new Map()
    };

const OPTIMIZE_LISTS = true; 
const OPTIMIZE_BUILD_RESULTS = true; // If TRUE: Limits results (e.g. Top 3 RAMs only). Default: ON.
const OPTIMIZE_CASE_SELECTION = true;  // If TRUE: Auto-selects the #1 Cheapest valid Case only.

    
    const Loaded = { cpu: false, gpu: false, ram: false, mobo: false, cases: false, psu: false, cooler: false, fan: false, storage: false };

    // SQLite Global
    let sqlDB = null;
    let buildCount = 0;

    const selectedOptions = {
        vram: new Set(),
        length: new Set(),
        socket: new Set(),
        cpuNames: new Set(),
        gpuNames: new Set(),
        gpuCount: new Set(), 
        moboNames: new Set(),
        caseNames: new Set(),
        ramNames: new Map(), // Changed from Set to Map for quantity support
        ramSizes: new Set(), 
        ramMfgrs: new Set(), 
        ramFreqs: new Set(), 
        ssdNames: new Map(), 
        hddNames: new Map() 
    };

    let lastClickedOption = { category: null, index: -1 };
    let warningDismissed = false; 

    // Global State for Toggles
    let globalUseOC = false;
let globalPerfMode = false;
    let globalUseXMP = true;

    // Caching for Sorting (Still used by SQL query builder indirectly)
    const PRECALC_GPU_SORT = false; 
    const PRECALC_CPU_SORT = false;

    function setToggle(type, state) {
        if (type === 'oc') {
            if (currentMode === 'TSX' && state === true) return; // Prevent OC in TSX
            globalUseOC = state;
            
            const onBtn = document.getElementById('btnOC_On');
            const offBtn = document.getElementById('btnOC_Off');
            
            onBtn.classList.toggle('active', state);
            onBtn.classList.toggle('active-green', state); 
            offBtn.classList.toggle('active', !state);
            
        } else if (type === 'xmp') {
            globalUseXMP = state;
            
            const onBtn = document.getElementById('btnXMP_On');
            const offBtn = document.getElementById('btnXMP_Off');
            
            onBtn.classList.toggle('active', state);
            onBtn.classList.toggle('active-green', state); 

            offBtn.classList.toggle('active', !state);
        }
    }

    const filterKeywords = {
        cpuNames: {
            'AMD': ['AMD', 'Ryzen', 'Threadripper'],
            'Intel': ['Intel', 'Core', 'Pentium', 'Celeron']
        },
        gpuNames: {
            'NVIDIA': ['NVIDIA', 'GeForce', 'RTX', 'GTX', 'PNY', 'Palit', 'Colorful', 'ZOTAC', 'EVGA', 'ASUS'],
            'AMD': ['AMD', 'Radeon', 'RX', 'ASRock', 'Sapphire'],
            'Intel': ['Intel Arc', 'Arc A', 'Arc B']
        },
        socket: {
            'AMD': ['AM4', 'AM5', 'TR4', 'sTRX4'],
            'Intel': ['LGA 1151', 'LGA 1200', 'LGA 1700', 'LGA 1851', 'LGA 2066']
        }
    };

    let builds = []; // Only holds CURRENT PAGE now
    let currentMode = 'TS';
    let currentPage = 1;
    let itemsPerPage = 100;
    let currentPopupData = null;
    let currentDataTab = 'gpu';

    // Utility functions
    const formatCurrency = num => '$' + num.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
    const formatNumber = num => num.toLocaleString('en-US');
    const parseVal = id => parseFloat(document.getElementById(id).value.replace(/,/g, '')) || 0;
    const parseIntVal = id => parseInt(document.getElementById(id).value.replace(/,/g, '')) || 0;

['budget', 'minTargetScore', 'targetScore', 'minScoreInput', 'resLimit'].forEach(id => {
        const el = document.getElementById(id);
        if(el) {
            el.addEventListener('input', e => {
                let v = e.target.value.replace(/\D/g, '');
                e.target.value = v ? parseInt(v).toLocaleString('en-US') : '';
            });
        }
    });

    function setMode(m) {
        currentMode = m;
        document.getElementById('btnTS').classList.toggle('active', m === 'TS');
        document.getElementById('btnTSX').classList.toggle('active', m === 'TSX');
        
        const btnOC_On = document.getElementById('btnOC_On');
        const btnOC_Off = document.getElementById('btnOC_Off');

        if (m === 'TSX') {
            setToggle('oc', false); 
            btnOC_On.disabled = true;
            btnOC_Off.disabled = true;
        } else {
            btnOC_On.disabled = false;
            btnOC_Off.disabled = false;
        }
        
        if(Loaded.cpu && Loaded.gpu) generateBuilds();
    }

    function dismissWarning() {
        document.getElementById('perfWarning').classList.add('hidden');
        warningDismissed = true;
    }

    // ==========================================
    // SQLITE INITIALIZATION
    // ==========================================

    async function initSQLite() {
        if (sqlDB) return;
        try {
            const SQL = await initSqlJs({
                locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
            });
            sqlDB = new SQL.Database();
            
            // Create Schema with Indices for TURBO speed
            sqlDB.run(`
                CREATE TABLE builds (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    score INTEGER,
                    liveCpuScore INTEGER,
                    gpuScore INTEGER,
                    diff INTEGER,
                    price REAL,
                    watts INTEGER,
                    cpuName TEXT,
                    gpuName TEXT,
                    gpuCnt INTEGER,
                    ramName TEXT,
                    ramSticks INTEGER,
                    moboName TEXT,
                    caseName TEXT,
                    coolerName TEXT,
                    psuName TEXT,
                    fanName TEXT,
                    storageNames TEXT
                );
                
                CREATE INDEX idx_score ON builds(score);
                CREATE INDEX idx_price ON builds(price);
                CREATE INDEX idx_diff ON builds(ABS(diff));
                CREATE INDEX idx_gpu_score ON builds(gpuScore);
                CREATE INDEX idx_cpu_score ON builds(liveCpuScore);
            `);
            console.log("SQLite Database Initialized");
        } catch (e) {
            console.error("Failed to init SQLite", e);
            alert("Failed to load SQL engine. Browser may not support WASM.");
        }
    }


function togglePerfMode() {
    globalPerfMode = !globalPerfMode;
    const btn = document.getElementById('btnPerfMode');
    
    if (globalPerfMode) {
        btn.classList.add('active', 'active-green');
        btn.innerText = "ON";
    } else {
        btn.classList.remove('active', 'active-green');
        btn.innerText = "OFF";
    }
}

    function clearSQLite() {
        if(sqlDB) {
            sqlDB.run('DELETE FROM builds'); // Faster than Drop/Create
            // Reset auto increment
            sqlDB.run('DELETE FROM sqlite_sequence WHERE name="builds"');
        }
        buildCount = 0;
    }

    function getTotalBuilds() {
        if(!sqlDB) return 0;
        const result = sqlDB.exec('SELECT COUNT(*) FROM builds');
        if(!result.length) return 0;
        return result[0].values[0][0];
    }

    function getScoreRange() {
        if(!sqlDB) return { min: 0, max: 0 };
        const result = sqlDB.exec('SELECT MIN(score), MAX(score) FROM builds');
        if (!result.length || !result[0].values[0][0]) return { min: 0, max: 0 };
        return { min: result[0].values[0][0], max: result[0].values[0][1] };
    }

/**
 * INTELLIGENT RAM FILTER
 * Updates the 'Specific RAM Model' list based on:
 * 1. Current Career Level
 * 2. Selected Manufacturers
 * 3. Selected Frequencies
 * 4. Selected Sizes
 */
function refreshRamOptions() {
    const currentLvl = parseInt(document.getElementById('level').value) || 30;

    // 1. Start with all RAMs allowed by Level
    let validRams = Array.from(DB.ram.values()).filter(r => r.level <= currentLvl);

    // 2. Filter by Manufacturer (if any selected)
    if (selectedOptions.ramMfgrs.size > 0) {
        validRams = validRams.filter(r => selectedOptions.ramMfgrs.has(r.mfgr));
    }

    // 3. Filter by Frequency (if any selected)
    if (selectedOptions.ramFreqs.size > 0) {
        validRams = validRams.filter(r => selectedOptions.ramFreqs.has(r.freq));
    }

    // 4. Filter by Size (if any selected)
    if (selectedOptions.ramSizes.size > 0) {
        validRams = validRams.filter(r => selectedOptions.ramSizes.has(r.size));
    }

    // 5. NEW: Smart Compatibility Filter
    // If user has already selected RAM(s), only show compatible ones
    // 5. NEW: Smart Compatibility Filter
// If user has already selected RAM(s), only show compatible ones
if (selectedOptions.ramNames.size > 0) {
    const selectedRamArray = Array.from(selectedOptions.ramNames.keys()).map(name => DB.ram.get(name));
    const firstRam = selectedRamArray[0];
    
    if (firstRam) {
        // Only show RAMs that match: Same Manufacturer AND Same DDR Type
        validRams = validRams.filter(r => {
            return r.mfgr === firstRam.mfgr && r.type === firstRam.type;
        });
    }
}


    // 6. Update the dropdown list
    populateMultiSelect('ramNames', validRams.map(r => r.name).sort(), 'ramListContainer');
}

    function getBuildsFromSQL(sortKey, limit, offset = 0) {
    if(!sqlDB) return [];
    
    let orderBy = 'ABS(diff) ASC'; 
    
    if (sortKey === 'score_desc') orderBy = 'score DESC';
    else if (sortKey === 'score_asc') orderBy = 'score ASC';
    else if (sortKey === 'price_asc') orderBy = 'price ASC';
    else if (sortKey === 'price_desc') orderBy = 'price DESC';
    else if (sortKey === 'gpu_score') orderBy = 'gpuScore DESC';
    else if (sortKey === 'cpu_score') orderBy = 'liveCpuScore DESC';
    else if (sortKey === 'value_desc') orderBy = '(score * 1.0 / price) DESC';
    else if (sortKey === 'value_asc') orderBy = '(score * 1.0 / price) ASC';
    
    const stmt = sqlDB.prepare(`
        SELECT * FROM builds 
        ORDER BY ${orderBy}
        LIMIT $limit OFFSET $offset
    `);
    
    stmt.bind({$limit: limit, $offset: offset});
    
    const output = [];
    while(stmt.step()) {
        const row = stmt.getAsObject();
        const storageNames = JSON.parse(row.storageNames || '[]');
        
        // Construct the build object
        const buildObj = {
            score: row.score,
            liveCpuScore: row.liveCpuScore,
            gpuScore: row.gpuScore,
            diff: row.diff,
            price: row.price,
            watts: row.watts,
            cpu: DB.cpu.get(row.cpuName),
            gpu: DB.gpu.get(row.gpuName),
            gpuCnt: row.gpuCnt,
            ram: row.ramName ? DB.ram.get(row.ramName) : null,
            ramSticks: row.ramSticks,
            mobo: row.moboName ? DB.mobo.get(row.moboName) : null,
            case: row.caseName ? DB.cases.get(row.caseName) : null,
            cooler: row.coolerName ? DB.cooler.get(row.coolerName) : null,
            psu: row.psuName ? DB.psu.get(row.psuName) : null,
            fan: row.fanName ? DB.fan.get(row.fanName) : null,
            storages: storageNames.map(n => DB.storage.get(n)).filter(Boolean)
        };

        // NEW: Store a snapshot of the original parts to track changes
        buildObj.original = {
            ram: buildObj.ram,
    ramSticks: buildObj.ramSticks, // ADD THIS LINE
            mobo: buildObj.mobo,
            case: buildObj.case,
            cooler: buildObj.cooler,
            psu: buildObj.psu,
            fan: buildObj.fan,
            // Storage is an array, shallow copy it
            storages: [...buildObj.storages]
        };

        output.push(buildObj);
    }
    stmt.free();
    return output;
}

    // ==========================================
    // DATA FETCHING
    // ==========================================

    window.addEventListener('DOMContentLoaded', initAutoFetcher);

    async function initAutoFetcher() {
        Object.keys(DB).forEach(k => DB[k].clear());
        Object.keys(Loaded).forEach(k => Loaded[k] = false);

        await initSQLite(); // Init DB on load

        const targets = [
            { id: 'cpu',       file: 'CPU.txt',              label: 'CPU' },
            { id: 'gpu',       file: 'GPU.txt',              label: 'GPU' },
            { id: 'water_gpu', file: 'Water Cooled GPU.txt', label: 'Water GPU' },
            { id: 'ram',       file: 'RAM.txt',              label: 'RAM' },
            { id: 'mobo',      file: 'Motherboard.txt',      label: 'Motherboard' },
            { id: 'cases',     file: 'Cases.txt',            label: 'Cases' },
            { id: 'cooler',    file: 'Coolers.txt',          label: 'Cooler' },
            { id: 'psu',       file: 'PSU.txt',              label: 'PSU' },
            { id: 'fan',       file: 'Case Fans.txt',        label: 'Fans' },
            { id: 'storage',   file: 'Storage.txt',          label: 'Storage' }
        ];

        const loadingText = document.getElementById('loadingText');

        for (const t of targets) {
            loadingText.innerText = `Fetching ${t.label}...`;
            try {
                const response = await fetch(`datas/${t.file}`);
                if (!response.ok) throw new Error(`Status ${response.status}`);
                const text = await response.text();
                parseHTML(t.file, text);

            } catch (err) {
                console.warn(`Could not load ${t.file}:`, err);
            }
        }

        loadingText.innerText = "Processing Data...";
        setTimeout(() => {
             document.getElementById('loadingOverlay').style.opacity = '0';
             setTimeout(() => {
                 document.getElementById('loadingOverlay').style.display = 'none';
                 if (currentMode === 'TSX') {
                    setToggle('oc', false);
                    document.getElementById('btnOC_On').disabled = true;
                    document.getElementById('btnOC_Off').disabled = true;
                 }
             }, 500);
        }, 500);
    }

    function parseHTML(fname, html) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const rows = Array.from(doc.querySelectorAll('tr'));
        if (rows.length < 2) return 0;

        const headers = Array.from(rows[0].querySelectorAll('td')).map(td => td.getAttribute('div') || td.textContent.trim());
        const idx = {};
        headers.forEach((h, i) => idx[h] = i);
        
        const get = (cells, key) => (idx[key] !== undefined && cells[idx[key]]) ? cells[idx[key]].textContent.trim() : '';
        const getNum = (cells, key) => {
            const val = get(cells, key);
            if (!val) return 0;
            return parseFloat(val.replace(/[^\d.-]/g, '')) || 0;
        };

        let type = '';
        const n = fname.toLowerCase();
        
        if (n.includes('cpu.txt')) type = 'cpu';
        else if (n.includes('gpu')) type = 'gpu';
        else if (n.includes('ram')) type = 'ram';
        else if (n.includes('motherboard')) type = 'mobo';
        else if (n.includes('cases')) type = 'cases';
        else if (n.includes('cooler')) type = 'cooler';
        else if (n.includes('psu') || n.includes('power supplies')) type = 'psu';
        else if (n.includes('case fans') || n.includes('fans')) type = 'fan';
        else if (n.includes('storage')) type = 'storage';

        if (!type) return 0;
        let addedCount = 0; 

        for (let i = 1; i < rows.length; i++) {
            const cells = rows[i].querySelectorAll('td');
            if (!cells.length) continue;
            
            const price = getNum(cells, 'Price');
            if (price <= 0) continue;

            const base = {
                name: get(cells, 'Part Name'),
                price: price,
                sellPrice: get(cells, 'Sell Price') || "0",
                level: parseInt(get(cells, 'Level')) || 0,
                mfgr: get(cells, 'Manufacturer')
            };

            if (type === 'cpu') {
                base.scoreTS = getNum(cells, 'Basic CPU Score (TS)');
                base.scoreTSX = getNum(cells, 'Basic CPU Score (TSX)');
                if (!base.scoreTS) base.scoreTS = base.scoreTSX;
                base.socket = get(cells, 'CPU Socket');
                base.watts = getNum(cells, 'Wattage');
                
                base.coreClockMultTS = getNum(cells, 'Core Clock Multiplier (TS)');
                base.multTS = getNum(cells, 'Mem Clock Multiplier (TS)');
                base.memChannelMultTS = getNum(cells, 'Mem Channels Multiplier (TS)');
                base.finalAdjTS = getNum(cells, 'Final Adjustment (TS)');
                base.coreClockMultTSX = getNum(cells, 'Core Clock Multiplier (TSX)');
                base.multTSX = getNum(cells, 'Mem Clock Multiplier (TSX)');   
                base.memChannelMultTSX = getNum(cells, 'Mem Channels Multiplier (TSX)');
                base.finalAdjTSX = getNum(cells, 'Final Adjustment (TSX)');
                base.defaultMem = getNum(cells, 'Default Memory Speed') || 2133;


                base.maxMemChannels = getNum(cells, 'Max Memory Channels') || 2;
                base.maxMemChannelsRaw = get(cells, 'Max Memory Channels');
                base.defaultMem = getNum(cells, 'Default Memory Speed') || 2133;
                base.memTypes = get(cells, 'Supported Memory Types');
                base.cores = get(cells, 'Cores');
                
                base.stdFreq = getNum(cells, 'Frequency');       
                base.baseFreq = getNum(cells, 'Base Frequency'); 
                base.maxFreq = getNum(cells, 'Max Freq');        

                if (!base.stdFreq) base.stdFreq = base.baseFreq;
                if (!base.maxFreq) base.maxFreq = base.stdFreq;

                base.voltage = get(cells, 'Voltage');
                base.maxVoltage = get(cells, 'Max Voltage');
                base.canOC = get(cells, 'Can Overclock');
                base.ocScore = get(cells, 'Overclock Basic CPU Score') || "-";
                base.canDelid = get(cells, 'Can Delid');

            } else if (type === 'gpu') {
                base.score = getNum(cells, 'Single GPU Graphics Score');
                base.score2 = getNum(cells, 'Double GPU Graphics Score');
                base.score3 = getNum(cells, 'Triple GPU Graphics Score');
                base.score4 = getNum(cells, 'Quad GPU Graphics Score');
                base.rawScore = get(cells, 'Single GPU Graphics Score');
                base.rawScore2 = get(cells, 'Double GPU Graphics Score');
                base.rawScore3 = get(cells, 'Triple GPU Graphics Score');
                base.rawScore4 = get(cells, 'Quad GPU Graphics Score');
                base.watts = getNum(cells, 'Wattage');
                base.vram = getNum(cells, 'VRAM (GB)');
                base.length = getNum(cells, 'Length');
                base.multi = get(cells, 'Double GPU supported') === 'Yes';
                base.sliType = get(cells, 'Double GPU SLI') === 'Yes' ? 'SLI' : 'Crossfire';
                base.isWater = n.includes('water');
                base.baseCore = get(cells, 'Base Core Clock Freq');
                base.baseMem = get(cells, 'Base Mem Clock Freq');
                base.maxCore = get(cells, 'GPU max clock');
                base.maxMem = get(cells, 'GPU max mem clock');
                base.chipset = get(cells, 'Chipset');
                base.slotSize = get(cells, 'Slot Size') || get(cells, 'Size') || "N/A";

            } else if (type === 'ram') {
                base.freq = getNum(cells, 'Frequency');
                base.type = get(cells, 'Ram Type');
                base.size = getNum(cells, 'Size each (GB)');
                base.totalSize = getNum(cells, 'Total Size (GB)');
                base.voltage = get(cells, 'Voltage');
                base.maxVoltage = get(cells, 'Max Voltage');
                base.maxSpeed = getNum(cells, 'Max Speed');
                base.mfgr = get(cells, 'Manufacturer') || get(cells, 'Brand');
                base.name = `${base.name} ${base.freq}MHz ${base.size}GB`;

            } else if (type === 'mobo') {
                base.socket = get(cells, 'CPU Socket');
                base.ramType = get(cells, 'Ram Type');
                base.size = get(cells, 'Motherboard Size');
                base.pciSlots = getNum(cells, 'PCI Slots');
                base.supportSLI = get(cells, 'Support SLI') === 'Yes';
                base.supportCF = get(cells, 'Support Crossfire') === 'Yes';
                base.maxMemSpeed = getNum(cells, 'Max Memory Speed'); 
base.defaultMem = getNum(cells, 'Default Memory Speed') || 2133;

            } else if (type === 'cases') {
                base.size = get(cells, 'Case Size');
                base.moboSizes = get(cells, 'Motherboard Size');
                base.maxGpuLen = getNum(cells, 'Max GPU length');
                base.maxCpuHeight = getNum(cells, 'Max CPU Fan Height');
                base.maxPsuLen = getNum(cells, 'Max PSU length');
                base.radSizes = get(cells, 'Max Radiator Sizes') || "";
                base.gpuSlots = getNum(cells, 'GPU Slots');
                base.ssdSlots = getNum(cells, 'SSD Slots');
                base.hddSlots = getNum(cells, 'HDD Slots');
            } else if (type === 'cooler') {
                base.type = get(cells, 'Type');
                base.height = getNum(cells, 'Height');
                base.size = getNum(cells, 'Size');
                base.sockets = get(cells, 'CPU Socket List');
                base.flow = getNum(cells, 'Air Flow');
            } else if (type === 'psu') {
                base.watts = getNum(cells, 'Wattage');
                base.length = getNum(cells, 'Length');
            } else if (type === 'fan') {
                base.size = getNum(cells, 'Size');
                base.flow = getNum(cells, 'Air Flow');
            } else if (type === 'storage') {
                base.sizeGB = getNum(cells, 'Size (GB)');
                base.sizeStr = base.sizeGB >= 1000 ? (base.sizeGB/1000)+'TB' : base.sizeGB+'GB';
                base.speed = getNum(cells, 'Transfer Speed') || getNum(cells, 'Speed');
                base.type = get(cells, 'Type');
                base.mfgr = get(cells, 'Manufacturer');
                base.name = `${base.name} (${base.sizeStr})`;
            }

            DB[type].set(base.name, base);
            addedCount++; 
        }

        Loaded[type] = true;
        updateStatus();
        return addedCount; 
    }

    function updateStatus() {
        if (Loaded.cpu && Loaded.gpu && Loaded.mobo && Loaded.ram && Loaded.cases && Loaded.storage) {
            document.querySelector('.controls-wrapper').classList.add('active');
            refreshDropdowns();
            renderDataList();
        }
    }

    function toggleView() {
        const calcView = document.getElementById('calculatorView');
        const dataView = document.getElementById('dataView');
        const btn = document.getElementById('mainViewToggle');

        if (dataView.style.display === 'none' || !dataView.style.display) {
            calcView.style.display = 'none';
            dataView.style.display = 'block';
            btn.innerHTML = `<span style="font-size:1.4em; display:block; margin-bottom:5px;">Return to Calculator</span><span style="font-size:1.1em; font-weight:normal; color:#ccc;">Click to go back to the build calculator</span>`;
            renderDataList();
        } else {
            calcView.style.display = 'block';
            dataView.style.display = 'none';
            btn.innerHTML = `
                <span style="font-size:1.4em; display:block; margin-bottom:5px;">Data Viewer</span>
                <span style="font-size:1.1em; font-weight:normal; color:#ccc;">click this box to swap to the data info page where u can know right OC values, more info about parts, and countless more stuff</span>
            `;
        }
    }

    function switchDataTab(tab) {
        currentDataTab = tab;
        const btns = document.querySelectorAll('.v-tab-btn');
        btns.forEach(b => b.classList.remove('active'));
        if(tab === 'gpu') btns[0].classList.add('active');
        else btns[1].classList.add('active');
        renderDataList();
    }

    function filterDataList() {
        const q = document.getElementById('dataSearchBox').value.toLowerCase();
        const rows = document.querySelectorAll('.data-list-row');
        rows.forEach(r => {
            if (r.innerText.toLowerCase().includes(q)) r.style.display = 'block';
            else r.style.display = 'none';
        });
    }

    function renderDataList() {
        const container = document.getElementById('dataViewListContainer');
        container.innerHTML = '';
        const sortMode = document.getElementById('dataViewSort').value;
        
        let items = [];
        if (currentDataTab === 'gpu') items = Array.from(DB.gpu.values());
        else items = Array.from(DB.cpu.values());

        // SORTING LOGIC
        items.sort((a,b) => {
            let scoreA = 0, scoreB = 0;
            let priceA = a.price || 999999;
            let priceB = b.price || 999999;

            if (currentDataTab === 'gpu') {
                scoreA = a.score || 0; // Single GPU score
                scoreB = b.score || 0;
            } else {
                scoreA = a.scoreTS || 0; // Base CPU Score
                scoreB = b.scoreTS || 0;
            }

            if (sortMode === 'score_desc') return scoreB - scoreA;
            if (sortMode === 'score_asc') return scoreA - scoreB;
            if (sortMode === 'price_desc') return priceB - priceA;
            if (sortMode === 'price_asc') return priceA - priceB;
            
            // Value = Score / Price
            let valA = (priceA > 0) ? scoreA / priceA : 0;
            let valB = (priceB > 0) ? scoreB / priceB : 0;
            
            if (sortMode === 'val_desc') return valB - valA; // Most Overperforming (High value)
            if (sortMode === 'val_asc') return valA - valB; // Most Underperforming (Low value)
            
            return 0;
        });

        items.forEach(item => {
            const div = document.createElement('div');
            div.className = `data-list-row ${getBrandClass(item)}`;
            let str = "";
            if (currentDataTab === 'gpu') {
                const cooling = item.isWater ? "Water" : "Air";
                str = `Single GPU Score: ${item.rawScore || ""} | Double GPU Score ${item.rawScore2 || ""} | Triple GPU Score ${item.rawScore3 || ""} | Quad GPU Score ${item.rawScore4 || ""} | VRAM ${item.vram} | Length ${item.length} | Watt ${item.watts} | ${cooling} | Base Core/Max Core: ${item.baseCore || "?"}/${item.maxCore || "?"} MHz | Base Mem/Max Mem: ${item.baseMem || "?"}/${item.maxMem || "?"} MHz | Level ${item.level} | Price ${item.price} | Sell Price ${item.sellPrice} | Slot size: ${item.slotSize} |`;
            } else {
const freqStr = `${item.baseFreq || "?"} / ${item.stdFreq || "?"} / ${item.maxFreq || "?"}`;                str = `Basic Cpu Score: ${item.scoreTS} | Basic CPU Score (TSX): ${item.scoreTSX} | OC Score: ${item.ocScore} | Socket ${item.socket} | ${item.cores}C | BaseMidMaxFreq: ${freqStr} MHz | VoltageMinMax: ${item.voltage || "?"}/${item.maxVoltage || "?"} V | Can Delid ${item.canDelid} | Sell Price : ${item.sellPrice} | Price ${item.price} | Level ${item.level} | Max Memory Channels: ${item.maxMemChannelsRaw || "?"} | Supported Memory Types ${item.memTypes}`;
            }
            div.innerHTML = `<span class="item-name-list">${item.name}</span><span class="raw-string">${str}</span>`;
            container.appendChild(div);
        });
        filterDataList();
    }

    function getMultiGPUCap(name, length) {
        const n = name.toLowerCase();
        const len = length || 0;
        if (n.includes('r9 280')) return 4;
        if (n.includes('r9 290')) return 4;
        if (n.includes('gtx 970') && !n.includes('msi gtx 970 gaming 4g')) return 4;
        if (n.includes('rx vega 56')) return 3;
        if (n.includes('radeon vii')) return 3;
        if (n.includes('rx 470') || n.includes('rx 560') || n.includes('rx 570') || n.includes('rx 580') || n.includes('rx 590')) return 3;
        if (n.includes('msi gtx 970 gaming 4g')) return 3;
        if (n.includes('msi gtx 980 ti gaming 6g golden edition')) return 3;
        if (n.includes('rx 5500')) return 3;
        if (n.includes('rtx 2060') && len < 271) return 3;
        if (n.includes('gtx 1080 ti') && len < 290) return 3;
        if (n.includes('rx 6800 xt')) return 2;
        if (n.includes('gtx 1080 ti')) return 2; 
        if (n.includes('gtx 1070 ti')) return 2;
        if (n.includes('rx 5700')) return 2;
        if (n.includes('rtx 2060')) return 2; 
        if (n.includes('rtx 2070')) return 2;
        if (n.includes('rtx 3060') || n.includes('rtx 3080') || n.includes('rtx 3090')) return 2;
        return 1;
    }

    function refreshDropdowns() {
        if (!Loaded.cpu) return;

        const currentLvl = parseInt(document.getElementById('level').value) || 30;
        
        const allowsSingleGpu = selectedOptions.gpuCount.has(1) || selectedOptions.gpuCount.size === 0;

        let moboFilterMinPCI = 0;
        let caseFilterMinGPU = 0;

        if (!allowsSingleGpu) {
            moboFilterMinPCI = 5;
            caseFilterMinGPU = 3;
        }

        const cpus = Array.from(DB.cpu.values()).filter(c => c.level <= currentLvl);
        const gpus = Array.from(DB.gpu.values()).filter(g => g.level <= currentLvl);
        const rams = Array.from(DB.ram.values()).filter(r => r.level <= currentLvl);
        const allStorage = Array.from(DB.storage.values()).filter(s => s.level <= currentLvl);
        
        const ssdList = allStorage.filter(s => s.type === 'SSD' || s.type === 'M.2');
        const hddList = allStorage.filter(s => s.type === 'HDD');
        
        const mobos = Array.from(DB.mobo.values()).filter(m => m.level <= currentLvl && m.pciSlots >= moboFilterMinPCI);
        const cases = Array.from(DB.cases.values()).filter(c => c.level <= currentLvl && c.gpuSlots >= caseFilterMinGPU);

        populateMultiSelect('gpuCount', [1, 2, 3, 4], 'gpuCountListContainer');
        populateMultiSelect('socket', [...new Set(cpus.map(c => c.socket).filter(s => s))].sort(), 'socketListContainer');
        populateMultiSelect('cpuNames', cpus.map(c => c.name).sort(), 'cpuListContainer');
        populateMultiSelect('vram', [...new Set(gpus.map(g => g.vram).filter(v => v))].sort((a,b) => a-b), 'vramListContainer');
        populateMultiSelect('length', [...new Set(gpus.map(g => g.length).filter(l => l))].sort((a,b) => a-b), 'lengthListContainer');
        populateMultiSelect('gpuNames', [...new Set(gpus.map(g => g.name))].sort(), 'gpuListContainer');
        populateMultiSelect('moboNames', mobos.map(m => m.name).sort(), 'moboListContainer');
        populateMultiSelect('caseNames', cases.map(c => c.name).sort(), 'caseListContainer');
            refreshRamOptions(); 
        
        populateMultiSelect('ssdNames', ssdList.map(s => s.name).sort(), 'ssdListContainer');
        populateMultiSelect('hddNames', hddList.map(s => s.name).sort(), 'hddListContainer');
        
        populateMultiSelect('ramMfgrs', [...new Set(rams.map(r => r.mfgr).filter(m => m))].sort(), 'ramMfgrListContainer');
        populateMultiSelect('ramFreqs', [...new Set(rams.map(r => r.freq).filter(f => f))].sort((a,b) => a-b), 'ramFreqListContainer');
        populateMultiSelect('ramSizes', [...new Set(rams.map(r => r.size).filter(s => s))].sort((a,b) => a-b), 'ramSizeListContainer');

        populateStorageSizeButtons('ssd', ssdList);
        populateStorageSizeButtons('hdd', hddList);

        const stickSelect = document.getElementById('ramSticks');
        const fourStickOption = stickSelect.querySelector('option[value="4"]');
        const canSupport4Sticks = mobos.some(m => m.size !== 'Mini-ITX');
        
        if (canSupport4Sticks) {
            fourStickOption.disabled = false;
            fourStickOption.innerText = "4 Sticks";
        } else {
            fourStickOption.disabled = true;
            fourStickOption.innerText = "4 Sticks (Not Available at Level " + currentLvl + ")";
            if(stickSelect.value == "4") stickSelect.value = "2";
        }
    }

    function populateStorageSizeButtons(type, list) {
        const container = document.getElementById(type + 'QuickFilter');
        const oldBtns = container.querySelectorAll('.btn-size-filter');
        oldBtns.forEach(b => b.remove());

        const uniqueSizes = [...new Set(list.map(s => s.sizeStr))];
        uniqueSizes.sort((a,b) => {
            const getVal = (str) => {
                let n = parseFloat(str);
                if(str.includes('TB')) n *= 1024 * 1024;
                else if(str.includes('GB')) n *= 1024;
                return n;
            }
            return getVal(a) - getVal(b);
        });

        uniqueSizes.forEach(size => {
            const btn = document.createElement('button');
            btn.className = 'filter-btn btn-size-filter';
            btn.innerText = size;
            btn.onclick = () => applySizeFilter(type, size);
            container.appendChild(btn);
        });
    }

    function applySizeFilter(type, sizeStr) {
        const containerId = type + 'ListContainer';
        const container = document.getElementById(containerId);
        const options = container.querySelectorAll('.multi-option');
        options.forEach(opt => {
            if (opt.dataset.sizeStr === sizeStr) opt.style.display = 'flex';
            else opt.style.display = 'none';
        });
    }

    window.addEventListener('click', function(e) {
        if (!e.target.matches('.multi-select-display') && !e.target.closest('.multi-dropdown')) {
            document.querySelectorAll('.multi-dropdown').forEach(d => d.classList.remove('show'));
        }
    });

    function toggleDropdown(id) {
        const target = document.getElementById(id);
        const isShown = target.classList.contains('show');
        document.querySelectorAll('.multi-dropdown').forEach(d => d.classList.remove('show'));
        if (!isShown) target.classList.add('show');
        const searchInput = target.querySelector('.dropdown-search');
        if (searchInput && !isShown) setTimeout(() => searchInput.focus(), 100);
    }
    
    function populateMultiSelect(category, options, containerId) {
        const container = document.getElementById(containerId);
        container.innerHTML = '';
        const isStorage = (category === 'ssdNames' || category === 'hddNames');

        options.forEach((opt, index) => {
            const div = document.createElement('div');
            div.className = 'multi-option';
            let isSelected = false;
            let count = 0;

            if (isStorage) {
                if (selectedOptions[category].has(opt)) {
                    isSelected = true;
                    count = selectedOptions[category].get(opt);
                }
                const s = DB.storage.get(opt);
                if(s) div.dataset.sizeStr = s.sizeStr;
            } else {
                if (selectedOptions[category].has(opt)) isSelected = true;
            }

            if (isSelected) div.classList.add('selected');
            div.dataset.value = opt;
            div.dataset.index = index; 
            
            let label = opt;
            
            if (category === 'ramNames') {
                const r = DB.ram.get(opt);
                if (r) {
                    label = `<span style="font-size:1.2em"><b>${r.mfgr || 'Generic'}</b> - ${r.name} | Size Each: ${r.size}GB | Total: ${r.totalSize}GB | ${r.type} | ${r.freq}/${r.maxSpeed} MHz | ${r.voltage}/${r.maxVoltage} V | Lvl: ${r.level}</span>`;
                }
            } else if (category === 'moboNames') {
                const m = DB.mobo.get(opt);
                if (m) label = `<span style="font-size:0.9em">${m.name} | PCI Slots: ${m.pciSlots}</span>`;
            } else if (category === 'caseNames') {
                const c = DB.cases.get(opt);
                if (c) label = `<span style="font-size:0.9em">${c.name} | GPU Slots: ${c.gpuSlots}</span>`;
            } else if (isStorage) {
                const s = DB.storage.get(opt);
                if (s) label = `<span style="font-size:0.9em">${s.name} | ${s.sizeStr} | ${s.speed} MB/s</span>`;
            } else {
                if (category === 'vram') label += ' GB';
                if (category === 'length') label += ' mm';
                if (category === 'ramFreqs') label += ' MHz';
                if (category === 'ramSizes') label += ' GB'; 
                if (category === 'gpuCount') {
                     if(opt == 1) label = "Single GPU";
                     if(opt == 2) label = "Dual GPU";
                     if(opt == 3) label = "Triple GPU";
                     if(opt == 4) label = "Quad GPU";
                }
            }

            if (isStorage) {
                const safeName = opt.replace(/'/g, "\\'");
                div.innerHTML = `
                    <div class="option-left" onclick="toggleStorageSelection('${category}', '${safeName}', 1)">
                        <div class="cb-custom"></div>
                        <span>${label}</span>
                    </div>
                    <div class="qty-controls" onclick="event.stopPropagation()">
                        <button class="qty-btn" onclick="modifyStorageQty('${category}', '${safeName}', -1)">-</button>
                        <span class="qty-val">${count}</span>
                        <button class="qty-btn" onclick="modifyStorageQty('${category}', '${safeName}', 1)">+</button>
                    </div>
                `;
            } else if (category === 'ramNames') {
                // NEW: RAM with quantity controls like storage
                const safeName = opt.replace(/'/g, "\\'");
                const ramCount = selectedOptions[category].has(opt) ? selectedOptions[category].get(opt) : 0;
                if (ramCount > 0) {
                    isSelected = true;
                    div.classList.add('selected');
                }
div.innerHTML = `
    <div class="option-left" onclick="event.stopPropagation(); toggleRamSelection('${safeName}', 1);">
        <div class="cb-custom"></div>
        <span>${label}</span>
    </div>
    <div class="qty-controls" onclick="event.stopPropagation()">

                        <button class="qty-btn" onclick="modifyRamQty('${safeName}', -1)">-</button>
                        <span class="qty-val">${ramCount}</span>
                        <button class="qty-btn" onclick="modifyRamQty('${safeName}', 1)">+</button>
                    </div>
                `;
            } else {
                div.innerHTML = `<div class="cb-custom"></div><span>${label}</span>`;
                div.onclick = (e) => toggleOption(category, opt, div, e);
            }
            
            container.appendChild(div);
        });
        
        updateDisplayLabel(category);
    }

    window.toggleStorageSelection = function(category, value, defaultQty) {
        if (selectedOptions[category].has(value)) {
            selectedOptions[category].delete(value);
        } else {
            selectedOptions[category].set(value, defaultQty);
        }
        refreshStorageDropdown(category);
        updateDisplayLabel(category);
    }

    window.modifyStorageQty = function(category, value, delta) {
        let current = selectedOptions[category].get(value) || 0;
        let next = current + delta;
        if (next <= 0) selectedOptions[category].delete(value);
        else selectedOptions[category].set(value, next);
        refreshStorageDropdown(category);
        updateDisplayLabel(category);
    }

    function refreshStorageDropdown(category) {
        const containerId = category === 'ssdNames' ? 'ssdListContainer' : 'hddListContainer';
        const list = (category === 'ssdNames') ? 
            Array.from(DB.storage.values()).filter(s => (s.type === 'SSD' || s.type === 'M.2')) :
            Array.from(DB.storage.values()).filter(s => s.type === 'HDD');
        
        const container = document.getElementById(containerId);
        const scrollTop = container.scrollTop;
        populateMultiSelect(category, list.map(s=>s.name).sort(), containerId);
        container.scrollTop = scrollTop;
    }


// NEW FUNCTION 1: Toggle RAM selection
window.toggleRamSelection = function(value, defaultQty) {
    if (selectedOptions.ramNames.has(value)) {
        selectedOptions.ramNames.delete(value);
    } else {
        selectedOptions.ramNames.set(value, defaultQty);
    }
    refreshRamDropdown();
    updateDisplayLabel('ramNames');
}

// NEW FUNCTION 2: Modify RAM quantity
window.modifyRamQty = function(value, delta) {
    let current = selectedOptions.ramNames.get(value) || 0;
    let next = current + delta;
    if (next <= 0) {
        selectedOptions.ramNames.delete(value);
    } else {
        selectedOptions.ramNames.set(value, next);
    }
    refreshRamDropdown();
    updateDisplayLabel('ramNames');
}

// NEW FUNCTION 3: Refresh RAM dropdown
function refreshRamDropdown() {
    const container = document.getElementById('ramListContainer');
    const scrollTop = container.scrollTop;
    refreshRamOptions(); // This will repopulate with smart filtering
    container.scrollTop = scrollTop;
}

    
function toggleOption(category, value, element, event) {
    // Handle Shift+Click Range Selection
    if (event.shiftKey && lastClickedOption.category === category && lastClickedOption.index !== -1) {
        const container = element.parentElement;
        // Get only currently visible options
        const options = Array.from(container.children).filter(c => c.style.display !== 'none');
        const currentIndex = options.indexOf(element);
        const lastIndex = options.findIndex(opt => parseInt(opt.dataset.index) === lastClickedOption.index);

        if (currentIndex !== -1 && lastIndex !== -1) {
            const start = Math.min(currentIndex, lastIndex);
            const end = Math.max(currentIndex, lastIndex);
            
            for (let i = start; i <= end; i++) {
                const opt = options[i];
                const val = opt.dataset.value;
                
                // Add to selection set
                if (category === 'gpuCount') selectedOptions[category].add(parseInt(val));
                else selectedOptions[category].add(val);
                
                opt.classList.add('selected');
            }
        }
    } 
    // Handle Standard Click (Toggle)
    else {
        if (selectedOptions[category].has(value)) {
            selectedOptions[category].delete(value);
            element.classList.remove('selected');
        } else {
            selectedOptions[category].add(value);
            element.classList.add('selected');
        }
    }

    // Update state for next click
    lastClickedOption = { category: category, index: parseInt(element.dataset.index) };
    
    // Update the label text (e.g. "3 selected")
    updateDisplayLabel(category);

    // --- NEW LOGIC: Update Specific RAM List ---
    // If we just clicked a Manufacturer, Frequency, or Size, refresh the specific model list
    if (['ramMfgrs', 'ramFreqs', 'ramSizes'].includes(category)) {
        refreshRamOptions();
    }
}


    function applyQuickFilter(category, type) {
        const keywords = filterKeywords[category][type];
        if (!keywords) return;
        let containerId = category === 'cpuNames' ? 'cpuListContainer' :
                         category === 'gpuNames' ? 'gpuListContainer' : 'socketListContainer';
        const container = document.getElementById(containerId);
        container.querySelectorAll('.multi-option').forEach(opt => {
            const val = opt.dataset.value;
            if (keywords.some(kw => val.includes(kw))) {
                opt.classList.add('selected');
                selectedOptions[category].add(val);
            }
        });
        updateDisplayLabel(category);
    }

    function clearFilter(category) {
    // 1. Clear the data set
    selectedOptions[category].clear();

    // 2. Determine which visual container to clear
    let containerId;
    if(category === 'cpuNames') containerId = 'cpuListContainer';
    else if(category === 'gpuNames') containerId = 'gpuListContainer';
    else if(category === 'socket') containerId = 'socketListContainer';
    else if(category === 'vram') containerId = 'vramListContainer';
    else if(category === 'length') containerId = 'lengthListContainer';
    else if(category === 'moboNames') containerId = 'moboListContainer';
    else if(category === 'ramNames') containerId = 'ramListContainer';
    else if(category === 'ramMfgrs') containerId = 'ramMfgrListContainer';
    else if(category === 'ramFreqs') containerId = 'ramFreqListContainer';
    else if(category === 'ramSizes') containerId = 'ramSizeListContainer';
    else if(category === 'gpuCount') containerId = 'gpuCountListContainer';
    else if(category === 'caseNames') containerId = 'caseListContainer';
    else if(category === 'ssdNames') containerId = 'ssdListContainer';
    else if(category === 'hddNames') containerId = 'hddListContainer';

// 3. Update the UI
    const container = document.getElementById(containerId);
    
    if (category === 'ssdNames' || category === 'hddNames') {
         // Special handling for storage (quantity based)
         refreshStorageDropdown(category);
         if(container) container.querySelectorAll('.multi-option').forEach(opt => opt.style.display = 'flex');
    } else if (category === 'ramNames') {
         // NEW: Special handling for RAM (quantity based)
         refreshRamDropdown();
    } else {
         // Standard handling: remove 'selected' class
         if(container) container.querySelectorAll('.multi-option').forEach(opt => opt.classList.remove('selected'));
    }
    
    // 4. Update Label text
    updateDisplayLabel(category);

    // --- NEW LOGIC: Update Specific RAM List ---
    // If we cleared a RAM filter, we need to refresh the list to show more options again
    if (['ramMfgrs', 'ramFreqs', 'ramSizes'].includes(category)) {
        refreshRamOptions();
    }
}

    function updateDisplayLabel(category) {
        let displayId;
        switch(category) {
            case 'vram': displayId = 'multiVram'; break;
            case 'length': displayId = 'multiLength'; break;
            case 'socket': displayId = 'multiSocket'; break;
            case 'cpuNames': displayId = 'multiCpu'; break;
            case 'gpuNames': displayId = 'multiGpu'; break;
            case 'gpuCount': displayId = 'multiGpuCount'; break;
            case 'ramNames': displayId = 'multiRam'; break;
            case 'ramMfgrs': displayId = 'multiRamMfgr'; break;
            case 'ramFreqs': displayId = 'multiRamFreq'; break;
            case 'ramSizes': displayId = 'multiRamSize'; break;
            case 'moboNames': displayId = 'multiMobo'; break;
            case 'caseNames': displayId = 'multiCase'; break;
            case 'ssdNames': displayId = 'multiSSD'; break;
            case 'hddNames': displayId = 'multiHDD'; break;
        }

        const display = document.getElementById(displayId).querySelector('.multi-select-display');
        const size = selectedOptions[category].size;

if (category === 'ssdNames' || category === 'hddNames') {
            let totalCount = 0;
            selectedOptions[category].forEach(qty => totalCount += qty);
            
            if (totalCount === 0) display.textContent = "Any";
            else display.textContent = `${totalCount} drives selected`;
            return;
        }

        // NEW: Handle RAM quantities
        if (category === 'ramNames') {
            let totalCount = 0;
            selectedOptions[category].forEach(qty => totalCount += qty);
            
            if (totalCount === 0) display.textContent = "Any";
            else display.textContent = `${totalCount} sticks selected`;
            return;
        }

        if (size === 0) {
            display.textContent = 'Any';
        } else if (size === 1) {
            let val = Array.from(selectedOptions[category])[0];
            if (category === 'vram') val += ' GB';
            if (category === 'length') val += ' mm';
            if (category === 'ramFreqs') val += ' MHz';
            if (category === 'ramSizes') val += ' GB';
            if (category === 'gpuCount') {
                if(val == 1) val = "Single GPU";
                else if(val == 2) val = "Dual GPU";
                else if(val == 3) val = "Triple GPU";
                else if(val == 4) val = "Quad GPU";
            }
            display.textContent = val;
        } else {
            if (['cpuNames','gpuNames','moboNames','caseNames','ramNames', 'ramMfgrs'].includes(category)) {
                display.textContent = `${size} selected`;
            } else {
                const arr = Array.from(selectedOptions[category]).sort((a,b) =>
                    (typeof a === 'number' ? a - b : String(a).localeCompare(String(b)))
                );
                let suffix = (category === 'vram' ? ' GB' : (category === 'length' ? ' mm' : (category === 'ramFreqs' ? ' MHz' : (category === 'ramSizes' ? ' GB' : ''))));
                if(category === 'gpuCount') display.textContent = `${size} configs selected`;
                else display.textContent = `${arr[0]}${suffix} + ${size - 1} others`;
            }
        }
    }

    function filterDropdownList(input) {
        const filter = input.value.toLowerCase();
        const container = input.closest('.multi-dropdown').querySelector('.dropdown-list-container');
        if (!container) return;
        container.querySelectorAll('.multi-option').forEach(item => {
            item.style.display = item.textContent.toLowerCase().includes(filter) ? 'flex' : 'none';
        });
    }

    function getBrandClass(item) {
        if (!item) return '';
        if (item.mfgr === 'Intel') {
            if (item.vram !== undefined) return 'brand-intel-gpu'; 
            return 'brand-intel'; 
        }
        if (item.mfgr === 'AMD') return 'brand-amd';
        if (item.mfgr === 'NVIDIA') return 'brand-nvidia';
        const searchStr = (item.name + " " + (item.chipset || "")).toLowerCase();
        if (searchStr.includes('radeon') || searchStr.includes('ryzen') || searchStr.includes('threadripper')) return 'brand-amd';
        if (searchStr.includes('geforce') || searchStr.includes('gtx') || searchStr.includes('rtx')) return 'brand-nvidia';
        if (searchStr.includes('arc ')) return 'brand-intel-gpu';
        return '';
    }
    
    // UPDATED: Can accept a RAM object OR raw numbers
function calculateCpuScore(cpu, ramOrFreq, stickCount, mode, useOC, useXMP, moboLimit = 0) {
    let freq = useOC ? cpu.maxFreq : cpu.stdFreq;
    if (!freq) freq = cpu.baseFreq;
    if (!freq) return 0;

    const isTS = (mode === 'TS');
    // Get Multipliers
    const coreMult = isTS ? cpu.coreClockMultTS : cpu.coreClockMultTSX;
    const memChanMult = isTS ? cpu.memChannelMultTS : cpu.memChannelMultTSX;
    const memClockMult = isTS ? cpu.multTS : cpu.multTSX;
    const adjustment = isTS ? cpu.finalAdjTS : cpu.finalAdjTSX;

    let activeChannels, actualMemSpeed;

    // Determine Memory Speed
    let targetRamFreq = 0;
    
    // Check if input is a RAM Object or just a number (Frequency)
    if (typeof ramOrFreq === 'object' && ramOrFreq !== null) {
        targetRamFreq = ramOrFreq.freq;
    } else {
        targetRamFreq = parseInt(ramOrFreq) || cpu.defaultMem || 2133;
    }

    // Determine Channels
    activeChannels = Math.min(stickCount, cpu.maxMemChannels);

    // Determine Actual Operating Speed (XMP vs JEDEC vs Mobo Limit)
    if (useXMP) {
        actualMemSpeed = targetRamFreq;
        if (moboLimit > 0 && actualMemSpeed > moboLimit) {
            actualMemSpeed = moboLimit;
        }
    } else {
        // Without XMP, it usually defaults to CPU default (e.g. 2133/2400) or the stick speed, whichever is lower
        actualMemSpeed = Math.min(targetRamFreq, (cpu.defaultMem || 2133));
    }

    const coreScore = coreMult * freq;
    const chanScore = memChanMult * activeChannels;
    const speedScore = memClockMult * actualMemSpeed;
    const sum = coreScore + chanScore + speedScore + adjustment;

    const final = Math.floor(sum * 298);
    return final > 0 ? final : 0;
}

    function calculate3DMark(cpuScore, gpuScore) {
        if (!cpuScore || !gpuScore) return 0;
        return Math.floor(1 / ((0.85 / gpuScore) + (0.15 / cpuScore)));
    }

    // =========================================================
    // OPTIMIZATION HELPER FUNCTIONS
    // =========================================================

    function getOptimizedMoboList(allMobos, lvl) {
        if (selectedOptions.moboNames.size > 0) {
            return allMobos.filter(m => m.level <= lvl && selectedOptions.moboNames.has(m.name));
        }

        const map = new Map();
        allMobos.forEach(m => {
            if (m.level > lvl) return;
            // Group by socket, ram type, size, PCI slots, and Max Memory Speed
            const key = `${m.socket}|${m.ramType}|${m.size}|${m.pciSlots}|${m.maxMemSpeed}|${m.supportSLI}|${m.supportCF}`;
            if (!map.has(key) || m.price < map.get(key).price) {
                map.set(key, m);
            }
        });

        return Array.from(map.values()).sort((a,b) => a.price - b.price);
    }

    function getOptimizedGpuList(allGpus, lvl) {
        // 1. If user selected specific GPUs in the filter menu, return ONLY those.
        if (selectedOptions.gpuNames.size > 0) {
            return allGpus.filter(g => g.level <= lvl && selectedOptions.gpuNames.has(g.name));
        }

        const map = new Map();
        allGpus.forEach(g => {
            if (g.level > lvl) return;
            if (selectedOptions.vram.size > 0 && !selectedOptions.vram.has(g.vram)) return;
            if (selectedOptions.length.size > 0 && !selectedOptions.length.has(g.length)) return;

            // Calculate Max Multi-GPU count for this card
            const maxCap = getMultiGPUCap(g.name, g.length);

            // Generate a unique key based on performance stats
            let key = `${g.score}|${g.vram}|${g.watts}|${g.multi}|${g.isWater}|${maxCap}`;

            // --- UPDATE: FORCE INCLUDE R9 280 & GTX 970 ---
            // We append the name to the key for these specific cards.
            // This prevents them from being filtered out if a "better value" generic card exists.
            const n = g.name.toLowerCase();
            if (n.includes('r9 280') || n.includes('gtx 970')) {
                key += `|${g.name}`; 
            }
            // ----------------------------------------------

            // If this key doesn't exist, or if this specific card is CHEAPER than the one stored, save it.
            if (!map.has(key) || g.price < map.get(key).price) {
                map.set(key, g);
            }
        });
        
        return Array.from(map.values()).sort((a,b) => b.score - a.score);
    }

    // =========================================================
    // MAIN GENERATOR FUNCTION (SQLITE POWERED)
    // =========================================================
    
    let precalcGpuConfigs = []; // Stores flattened valid GPU configs



    async function generateBuilds() {
        // Safety Checks
        if (!Loaded.cpu || !Loaded.gpu) return alert("Wait for Data Load!");
        
        // Ensure SQL is ready
        if (!sqlDB) {
            document.getElementById('loadingOverlay').style.display = 'flex';
            document.getElementById('loadingOverlay').style.opacity = '1';
            await initSQLite();
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        // Reset state
        builds = [];
        precalcGpuConfigs = [];
        clearSQLite();
        
        document.getElementById('resCount').innerText = "0% Scanned...";
        document.getElementById('scanStatus').innerText = "Running Scan...";
        
        const btn = document.getElementById('generateBtn');
        btn.disabled = true;
        btn.innerText = "SCANNING...";

        // --- 1. GATHER INPUTS ---
        const config = {
            budget: parseVal('budget'),
            minGenScore: parseVal('minTargetScore'), 
            maxGenScore: parseVal('targetScore'), 
            lvl: parseInt(document.getElementById('level').value) || 30,
            sort: document.getElementById('mainSort').value,
            useOC: globalUseOC,
            useXMP: globalUseXMP,
            useRamPerfMode: document.getElementById('ramPerfMode').checked,
            limitTotalW: parseInt(document.getElementById('maxTotalWatts').value),
            limitCpuW: parseInt(document.getElementById('maxCpuWatts').value),
            limitGpuW: parseInt(document.getElementById('maxGpuWatts').value),
            extraW: parseInt(document.getElementById('extraWatts').value) || 0,
            useRam: document.getElementById('incRam').checked && Loaded.ram,
            useMobo: document.getElementById('incMobo').checked && Loaded.mobo,
            useCase: document.getElementById('incCase').checked && Loaded.cases,
            useCooler: document.getElementById('incCooler').checked && Loaded.cooler,
            usePsu: document.getElementById('incPsu').checked && Loaded.psu,
            useFan: document.getElementById('incFans').checked && Loaded.fan,
            useStorage: document.getElementById('incStorage').checked && Loaded.storage,
            reqSticks: parseInt(document.getElementById('ramSticks').value),
            targetRamVal: parseIntVal('targetTotalRam'),
            currentMode: currentMode
        };

        // --- 2. PREPARE AUX LISTS (STRICT PRICE SORTING) ---
        // We explicitly sort these by Price Ascending so the assembler always picks the cheapest fit.
        
        let rawCases = Array.from(DB.cases.values()).filter(c => {
            if (c.level > config.lvl) return false;
            if (selectedOptions.caseNames.size > 0 && !selectedOptions.caseNames.has(c.name)) return false;
            return true;
        });
        
        const lists = {
            allCases: rawCases.sort((a,b) => a.price - b.price),
            
            allCoolers: config.useCooler ? Array.from(DB.cooler.values())
                .filter(c => c.level <= config.lvl)
                .sort((a,b) => a.price - b.price) : [],
                
            allPsu: config.usePsu ? Array.from(DB.psu.values())
                .filter(p => p.level <= config.lvl)
                .sort((a,b) => a.price - b.price) : [], // Ensure Cheapest PSU is first
                
            allFans: config.useFan ? Array.from(DB.fan.values())
                .filter(f => f.level <= config.lvl)
                .sort((a,b) => a.price - b.price) : []
        };
        
        // --- 3. STORAGE & MIN COSTS ---
        let minAuxCost = 0;
        let totalStorageCost = 0;
        let finalStorageList = [];

        selectedOptions.ssdNames.forEach((count, name) => {
            const part = DB.storage.get(name);
            if (part && part.level <= config.lvl) { 
                for(let i=0; i<count; i++) { finalStorageList.push(part); totalStorageCost += part.price; }
            }
        });
        selectedOptions.hddNames.forEach((count, name) => {
            const part = DB.storage.get(name);
            if (part && part.level <= config.lvl) { 
                for(let i=0; i<count; i++) { finalStorageList.push(part); totalStorageCost += part.price; }
            }
        });

        // Fallback storage if none selected but required
        if (config.useStorage && finalStorageList.length === 0) {
            const fallback = Array.from(DB.storage.values())
                .filter(s => s.type !== 'HDD' && s.level <= config.lvl)
                .sort((a,b) => a.price - b.price)[0];
            if (fallback) {
                finalStorageList.push(fallback);
                totalStorageCost += fallback.price;
            }
        }
        minAuxCost += totalStorageCost;

        // Add minimum costs of required parts to fail fast
        if (config.useCase && lists.allCases.length > 0) minAuxCost += lists.allCases[0].price;
        if (config.usePsu && lists.allPsu.length > 0) minAuxCost += lists.allPsu[0].price;
        if (config.useCooler && lists.allCoolers.length > 0) minAuxCost += lists.allCoolers[0].price;

        lists.minAuxCost = minAuxCost;
        lists.finalStorageList = finalStorageList;
        lists.totalStorageCost = totalStorageCost;

        // --- 4. PREPARE CPU LIST ---
        lists.validCpu = Array.from(DB.cpu.values()).filter(c => {
            if (c.level > config.lvl) return false;
            if (config.limitCpuW && (c.watts || 0) > config.limitCpuW) return false;
            if (selectedOptions.socket.size > 0 && !selectedOptions.socket.has(c.socket)) return false;
            if (selectedOptions.cpuNames.size > 0 && !selectedOptions.cpuNames.has(c.name)) return false;
            return true;
        }).sort((a,b) => (currentMode === 'TS' ? b.scoreTS - a.scoreTS : b.scoreTSX - a.scoreTSX));

        // --- 5. GPU LIST (RAW VS OPTIMIZED) ---
        let allGpus = [];
        if (OPTIMIZE_LISTS) {
            allGpus = getOptimizedGpuList(Array.from(DB.gpu.values()), config.lvl);
        } else {
            allGpus = Array.from(DB.gpu.values()).filter(g => {
                if (g.level > config.lvl) return false;
                if (selectedOptions.gpuNames.size > 0 && !selectedOptions.gpuNames.has(g.name)) return false;
                if (selectedOptions.vram.size > 0 && !selectedOptions.vram.has(g.vram)) return false;
                if (selectedOptions.length.size > 0 && !selectedOptions.length.has(g.length)) return false;
                return true;
            }).sort((a,b) => b.score - a.score);
        }

        // --- 6. FLATTEN GPU LIST (SINGLE/DUAL/ETC) ---
        let selectedCounts = Array.from(selectedOptions.gpuCount);
        if (selectedCounts.length === 0) selectedCounts = [1, 2, 3, 4];
        
        precalcGpuConfigs = [];
        for (const gpu of allGpus) {
             for (const cnt of selectedCounts) {
                 if (cnt === 2 && !gpu.score2) continue;
                 if (cnt === 3 && !gpu.score3) continue;
                 if (cnt === 4 && !gpu.score4) continue;
                 if (cnt > 1) {
                     const maxCap = getMultiGPUCap(gpu.name, gpu.length);
                     if (maxCap < cnt) continue;
                 }
                 
                 const totalGpuWatts = gpu.watts * cnt;
                 if (config.limitGpuW && gpu.watts > config.limitGpuW) continue;

                 const score = cnt === 1 ? gpu.score : (cnt === 2 ? gpu.score2 : (cnt === 3 ? gpu.score3 : gpu.score4));
                 if (!score) continue;

                 precalcGpuConfigs.push({
                     gpu: gpu,
                     count: cnt,
                     score: score,
                     price: gpu.price * cnt,
                     watts: totalGpuWatts,
                     sliType: cnt > 1 ? gpu.sliType : null
                 });
             }
        }
        
        // --- 7. MOTHERBOARD LIST ---
        let moboSource = Array.from(DB.mobo.values()).filter(m => {
            if (m.level > config.lvl) return false;
            if (selectedOptions.moboNames.size > 0 && !selectedOptions.moboNames.has(m.name)) return false;
            return true;
        });

        if (OPTIMIZE_BUILD_RESULTS) {
            lists.validMobos = getOptimizedMoboList(moboSource, config.lvl);
        } else {
            lists.validMobos = moboSource.sort((a,b) => a.price - b.price);
        }
        
        // Start Async Processing
        runScanChunk(0, config, lists);
    }



function runScanChunk(cpuIndex, config, lists) {
    if (cpuIndex >= lists.validCpu.length) {
        finishScan(config);
        return;
    }

    const cpu = lists.validCpu[cpuIndex];

    // 1. PRE-CALCULATE ALL UNIQUE FREQUENCIES
    const availableRams = Array.from(DB.ram.values()).filter(r => {
        if (r.level > config.lvl) return false;
        if (selectedOptions.ramNames.size > 0 && !selectedOptions.ramNames.has(r.name)) return false;
        if (selectedOptions.ramMfgrs.size > 0 && !selectedOptions.ramMfgrs.has(r.mfgr)) return false;
        if (selectedOptions.ramFreqs.size > 0 && !selectedOptions.ramFreqs.has(r.freq)) return false;
        if (selectedOptions.ramSizes.size > 0 && !selectedOptions.ramSizes.has(r.size)) return false;
        return true;
    });
    
    const uniqueXmpFreqs = [...new Set(availableRams.map(r => r.freq))].sort((a, b) => a - b);
    
    const cpuMobos = config.useMobo ? lists.validMobos.filter(m => m.socket === cpu.socket) : [null];
    const uniqueDefaultSpeeds = [...new Set(cpuMobos.filter(m => m !== null).map(m => m.defaultMem))].sort((a, b) => a - b);
    if (uniqueDefaultSpeeds.length === 0) uniqueDefaultSpeeds.push(cpu.defaultMem || 2133);

    sqlDB.run("BEGIN TRANSACTION");
    const stmt = sqlDB.prepare(`
        INSERT INTO builds (
            score, liveCpuScore, gpuScore, diff, price, watts,
            cpuName, gpuName, gpuCnt, ramName, ramSticks,
            moboName, caseName, coolerName, psuName, fanName, storageNames
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    // 2. GPU LOOP
    for (const gpuConf of precalcGpuConfigs) {
        if ((cpu.price + gpuConf.price) > config.budget) continue;

        // 3. STICKS LOOP
        const possibleSticks = config.reqSticks > 0 ? [config.reqSticks] : [1, 2, 4];

        for (const sticks of possibleSticks) {
            
            // Choose Frequency List
            const freqsToTest = config.useXMP ? uniqueXmpFreqs : uniqueDefaultSpeeds;

            // =========================================================
            //  LOGIC SPLIT: PERFORMANCE MODE (v1) VS THOROUGH (r)
            // =========================================================
            
            if (globalPerfMode) {
                // --- PERFORMANCE MODE ON (v1.txt Logic) ---
                // Stops looking for frequencies as soon as one works for this CPU/GPU/Stick combo
                
                let foundWorkingSpec = false;

                for (const freq of freqsToTest) {
                    if (foundWorkingSpec) break; // Optimization: Stop after first match

                    const liveCpuScore = calculateCpuScore(cpu, freq, sticks, config.currentMode, config.useOC, config.useXMP, 0);
                    const totalScore = calculate3DMark(liveCpuScore, gpuConf.score);

                    if (totalScore < config.minGenScore || totalScore > config.maxGenScore) continue;

                    foundWorkingSpec = true;

                    // Find RAM & Mobo for this freq
                    const validRams = availableRams.filter(r => {
                        if (r.freq < freq) return false;
                        if (!cpu.memTypes.includes(r.type)) return false;
                        if (config.targetRamVal > 0 && (r.size * sticks) !== config.targetRamVal) return false;
                        return true;
                    }).sort((a, b) => a.price - b.price);

                    if (validRams.length === 0) continue;

                    const validMobos = cpuMobos.filter(m => {
                        if (!m) return true;
                        if (validRams[0].type !== m.ramType) return false;
                        if (gpuConf.count > 1 && m.pciSlots < 5) return false;
                        if (gpuConf.sliType === 'SLI' && !m.supportSLI) return false;
                        if (gpuConf.sliType === 'Crossfire' && !m.supportCF) return false;
                        if (sticks === 4 && m.size === 'Mini-ITX') return false;
                        if (config.useXMP) { if (m.maxMemSpeed < freq) return false; } 
                        else { if (m.defaultMem !== freq) return false; }
                        return true;
                    });

                    // Optimization: Only use top 1 RAM
                    const ramCap = 1; 
                    assembleBuilds(validRams.slice(0, ramCap), validMobos, cpu, gpuConf, sticks, totalScore, liveCpuScore, config, lists, stmt);
                }

            } else {
                // --- PERFORMANCE MODE OFF (r.txt Logic) ---
                // Buffers ALL valid frequencies for this CPU/GPU/Stick combo, then generates builds for ALL of them.
                
                const validFreqCandidates = [];

                for (const freq of freqsToTest) {
                    const liveCpuScore = calculateCpuScore(cpu, freq, sticks, config.currentMode, config.useOC, config.useXMP, 0);
                    const totalScore = calculate3DMark(liveCpuScore, gpuConf.score);

                    if (totalScore < config.minGenScore || totalScore > config.maxGenScore) continue;

                    validFreqCandidates.push({ freq, totalScore, liveCpuScore });
                }

                for (const candidate of validFreqCandidates) {
                    const { freq, totalScore, liveCpuScore } = candidate;

                    const validRams = availableRams.filter(r => {
                        if (r.freq < freq) return false;
                        if (!cpu.memTypes.includes(r.type)) return false;
                        if (config.targetRamVal > 0 && (r.size * sticks) !== config.targetRamVal) return false;
                        return true;
                    }).sort((a, b) => a.price - b.price);

                    if (validRams.length === 0) continue;

                    const validMobos = cpuMobos.filter(m => {
                        if (!m) return true;
                        if (validRams[0].type !== m.ramType) return false;
                        if (gpuConf.count > 1 && m.pciSlots < 5) return false;
                        if (gpuConf.sliType === 'SLI' && !m.supportSLI) return false;
                        if (gpuConf.sliType === 'Crossfire' && !m.supportCF) return false;
                        if (sticks === 4 && m.size === 'Mini-ITX') return false;
                        if (config.useXMP) { if (m.maxMemSpeed < freq) return false; } 
                        else { if (m.defaultMem !== freq) return false; }
                        return true;
                    });

                    // Even in r.txt logic, we usually only pick the cheapest RAM per frequency to avoid DB explosion
                    const ramCap = 1;
                    assembleBuilds(validRams.slice(0, ramCap), validMobos, cpu, gpuConf, sticks, totalScore, liveCpuScore, config, lists, stmt);
                }
            }
        }
    }

    stmt.free();
    sqlDB.run("COMMIT");

    const percent = Math.floor(((cpuIndex + 1) / lists.validCpu.length) * 100);
    document.getElementById('resCount').innerText = `${percent}% | ${formatNumber(buildCount)} builds`;
    
    setTimeout(() => runScanChunk(cpuIndex + 1, config, lists), 0);
}

async function generateBuilds() {
        // Safety Checks
        if (!Loaded.cpu || !Loaded.gpu) return alert("Wait for Data Load!");
        
        // Ensure SQL is ready
        if (!sqlDB) {
            document.getElementById('loadingOverlay').style.display = 'flex';
            document.getElementById('loadingOverlay').style.opacity = '1';
            await initSQLite();
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        // Reset state
        builds = [];
        precalcGpuConfigs = [];
        clearSQLite();
        
        document.getElementById('resCount').innerText = "0% Scanned...";
        document.getElementById('scanStatus').innerText = "Running Scan...";
        
        const btn = document.getElementById('generateBtn');
        btn.disabled = true;
        btn.innerText = "SCANNING...";

        // --- 1. GATHER INPUTS ---
        const config = {
            budget: parseVal('budget'),
            minGenScore: parseVal('minTargetScore'), 
            maxGenScore: parseVal('targetScore'), 
            lvl: parseInt(document.getElementById('level').value) || 30,
            sort: document.getElementById('mainSort').value,
            useOC: globalUseOC,
            useXMP: globalUseXMP,
            useRamPerfMode: document.getElementById('ramPerfMode').checked,
            limitTotalW: parseInt(document.getElementById('maxTotalWatts').value),
            limitCpuW: parseInt(document.getElementById('maxCpuWatts').value),
            limitGpuW: parseInt(document.getElementById('maxGpuWatts').value),
            extraW: parseInt(document.getElementById('extraWatts').value) || 0,
            useRam: document.getElementById('incRam').checked && Loaded.ram,
            useMobo: document.getElementById('incMobo').checked && Loaded.mobo,
            useCase: document.getElementById('incCase').checked && Loaded.cases,
            useCooler: document.getElementById('incCooler').checked && Loaded.cooler,
            usePsu: document.getElementById('incPsu').checked && Loaded.psu,
            useFan: document.getElementById('incFans').checked && Loaded.fan,
            useStorage: document.getElementById('incStorage').checked && Loaded.storage,
            reqSticks: parseInt(document.getElementById('ramSticks').value),
            targetRamVal: parseIntVal('targetTotalRam'),
            currentMode: currentMode
        };

        // --- 2. PREPARE AUX LISTS (STRICT PRICE SORTING) ---
        // We explicitly sort these by Price Ascending so the assembler always picks the cheapest fit.
        
        let rawCases = Array.from(DB.cases.values()).filter(c => {
            if (c.level > config.lvl) return false;
            if (selectedOptions.caseNames.size > 0 && !selectedOptions.caseNames.has(c.name)) return false;
            return true;
        });
        
        const lists = {
            allCases: rawCases.sort((a,b) => a.price - b.price),
            
            allCoolers: config.useCooler ? Array.from(DB.cooler.values())
                .filter(c => c.level <= config.lvl)
                .sort((a,b) => a.price - b.price) : [],
                
            allPsu: config.usePsu ? Array.from(DB.psu.values())
                .filter(p => p.level <= config.lvl)
                .sort((a,b) => a.price - b.price) : [], // Ensure Cheapest PSU is first
                
            allFans: config.useFan ? Array.from(DB.fan.values())
                .filter(f => f.level <= config.lvl)
                .sort((a,b) => a.price - b.price) : []
        };
        
        // --- 3. STORAGE & MIN COSTS ---
        let minAuxCost = 0;
        let totalStorageCost = 0;
        let finalStorageList = [];

        selectedOptions.ssdNames.forEach((count, name) => {
            const part = DB.storage.get(name);
            if (part && part.level <= config.lvl) { 
                for(let i=0; i<count; i++) { finalStorageList.push(part); totalStorageCost += part.price; }
            }
        });
        selectedOptions.hddNames.forEach((count, name) => {
            const part = DB.storage.get(name);
            if (part && part.level <= config.lvl) { 
                for(let i=0; i<count; i++) { finalStorageList.push(part); totalStorageCost += part.price; }
            }
        });

        // Fallback storage if none selected but required
        if (config.useStorage && finalStorageList.length === 0) {
            const fallback = Array.from(DB.storage.values())
                .filter(s => s.type !== 'HDD' && s.level <= config.lvl)
                .sort((a,b) => a.price - b.price)[0];
            if (fallback) {
                finalStorageList.push(fallback);
                totalStorageCost += fallback.price;
            }
        }
        minAuxCost += totalStorageCost;

        // Add minimum costs of required parts to fail fast
        if (config.useCase && lists.allCases.length > 0) minAuxCost += lists.allCases[0].price;
        if (config.usePsu && lists.allPsu.length > 0) minAuxCost += lists.allPsu[0].price;
        if (config.useCooler && lists.allCoolers.length > 0) minAuxCost += lists.allCoolers[0].price;

        lists.minAuxCost = minAuxCost;
        lists.finalStorageList = finalStorageList;
        lists.totalStorageCost = totalStorageCost;

        // --- 4. PREPARE CPU LIST ---
        lists.validCpu = Array.from(DB.cpu.values()).filter(c => {
            if (c.level > config.lvl) return false;
            if (config.limitCpuW && (c.watts || 0) > config.limitCpuW) return false;
            if (selectedOptions.socket.size > 0 && !selectedOptions.socket.has(c.socket)) return false;
            if (selectedOptions.cpuNames.size > 0 && !selectedOptions.cpuNames.has(c.name)) return false;
            return true;
        }).sort((a,b) => (currentMode === 'TS' ? b.scoreTS - a.scoreTS : b.scoreTSX - a.scoreTSX));

        // --- 5. GPU LIST (RAW VS OPTIMIZED) ---
        let allGpus = [];
        if (OPTIMIZE_LISTS) {
            allGpus = getOptimizedGpuList(Array.from(DB.gpu.values()), config.lvl);
        } else {
            allGpus = Array.from(DB.gpu.values()).filter(g => {
                if (g.level > config.lvl) return false;
                if (selectedOptions.gpuNames.size > 0 && !selectedOptions.gpuNames.has(g.name)) return false;
                if (selectedOptions.vram.size > 0 && !selectedOptions.vram.has(g.vram)) return false;
                if (selectedOptions.length.size > 0 && !selectedOptions.length.has(g.length)) return false;
                return true;
            }).sort((a,b) => b.score - a.score);
        }

        // --- 6. FLATTEN GPU LIST (SINGLE/DUAL/ETC) ---
        let selectedCounts = Array.from(selectedOptions.gpuCount);
        if (selectedCounts.length === 0) selectedCounts = [1, 2, 3, 4];
        
        precalcGpuConfigs = [];
        for (const gpu of allGpus) {
             for (const cnt of selectedCounts) {
                 if (cnt === 2 && !gpu.score2) continue;
                 if (cnt === 3 && !gpu.score3) continue;
                 if (cnt === 4 && !gpu.score4) continue;
                 if (cnt > 1) {
                     const maxCap = getMultiGPUCap(gpu.name, gpu.length);
                     if (maxCap < cnt) continue;
                 }
                 
                 const totalGpuWatts = gpu.watts * cnt;
                 if (config.limitGpuW && gpu.watts > config.limitGpuW) continue;

                 const score = cnt === 1 ? gpu.score : (cnt === 2 ? gpu.score2 : (cnt === 3 ? gpu.score3 : gpu.score4));
                 if (!score) continue;

                 precalcGpuConfigs.push({
                     gpu: gpu,
                     count: cnt,
                     score: score,
                     price: gpu.price * cnt,
                     watts: totalGpuWatts,
                     sliType: cnt > 1 ? gpu.sliType : null
                 });
             }
        }
        
        // --- 7. MOTHERBOARD LIST ---
        let moboSource = Array.from(DB.mobo.values()).filter(m => {
            if (m.level > config.lvl) return false;
            if (selectedOptions.moboNames.size > 0 && !selectedOptions.moboNames.has(m.name)) return false;
            return true;
        });

        if (OPTIMIZE_BUILD_RESULTS) {
            lists.validMobos = getOptimizedMoboList(moboSource, config.lvl);
        } else {
            lists.validMobos = moboSource.sort((a,b) => a.price - b.price);
        }
        
        // Start Async Processing
        runScanChunk(0, config, lists);
    }

    function assembleBuilds(rams, mobos, cpu, gpuConf, sticks, score, cpuScore, config, lists, stmt) {
        // 1. Loop through RAMs
        for (const ram of rams) {
            
            // 2. Loop Mobos
            // Mobos are already sorted by Price. The first one that fits is the best one.
            for (const mobo of mobos) {

                // Optimization: Cost Check
                const corePrice = cpu.price + gpuConf.price + (ram.price * sticks) + (mobo ? mobo.price : 0);
                if (corePrice + lists.minAuxCost > config.budget) continue; 

                // Optimization: Wattage Check
                const totalWatts = cpu.watts + gpuConf.watts + config.extraW;
                if (config.limitTotalW && totalWatts > config.limitTotalW) continue;

                // 3. CASE SELECTION
                // lists.allCases is sorted by Price Ascending. .find() returns the CHEAPEST valid case.
                let validCase = null;
                if (config.useCase) {
                    validCase = lists.allCases.find(c => {
                        if (c.maxGpuLen < gpuConf.gpu.length) return false;
                        if (gpuConf.count > 1 && c.gpuSlots < 3) return false;
                        if (mobo && !c.moboSizes.includes(mobo.size)) return false;
                        return true;
                    });
                    if (!validCase) continue; 
                }

                // 4. COOLER / PSU / FAN SELECTION
                let currentPrice = corePrice + (validCase ? validCase.price : 0);

                // Cooler Selection (Cheapest Valid)
                let cooler = null;
                if (config.useCooler) {
                    cooler = lists.allCoolers.find(c => {
                       if (!c.sockets.includes(cpu.socket)) return false;
                       if (validCase && c.type.includes('Air') && validCase.maxCpuHeight < c.height) return false;
                       return true;
                    });
                    if (cooler) currentPrice += cooler.price;
                    else continue; 
                }

                // PSU Selection (Cheapest Valid)
                // Since lists.allPsu is sorted by price, .find() gets the cheapest one that meets Watts & Length.
                // PSU Selection (Minimum Wattage, Then Cheapest)
let psu = null;
if (config.usePsu) {
    // Find all PSUs that meet requirements
    const validPsus = lists.allPsu.filter(p => 
        p.watts >= totalWatts && 
        (!validCase || validCase.maxPsuLen === 0 || p.length <= validCase.maxPsuLen)
    );
    
    if (validPsus.length > 0) {
        // Sort by wattage FIRST (lowest wattage), THEN by price (cheapest)
        validPsus.sort((a, b) => {
            if (a.watts !== b.watts) return a.watts - b.watts; // Prefer lower wattage
            return a.price - b.price; // If same wattage, prefer cheaper
        });
        psu = validPsus[0];
        currentPrice += psu.price;
    } else {
        continue; // No valid PSU found
    }
}

                // Fans Selection (Cheapest Valid)
                let fan = null;
                if (config.useFan && validCase) {
                    fan = lists.allFans.find(f => true); // Assumes generic 120/140 fits if case exists
                    if (fan) currentPrice += fan.price;
                }

                // Final Budget Check
                currentPrice += lists.totalStorageCost;
                if (currentPrice > config.budget) continue;

                // 5. INSERT INTO DB
                const storageNameList = JSON.stringify(lists.finalStorageList.map(s => s.name));

                stmt.run([
                    score, cpuScore, gpuConf.score,
                    score - config.maxGenScore, 
                    currentPrice, totalWatts, cpu.name, gpuConf.gpu.name, gpuConf.count,
                    ram.name, sticks, mobo ? mobo.name : null, validCase ? validCase.name : null,
                    cooler ? cooler.name : null, psu ? psu.name : null, fan ? fan.name : null,
                    storageNameList
                ]);
                
                buildCount++;
                
                // OPTIMIZATION:
                // We found a working Case + Mobo + PSU for this specific RAM stick.
                // Since lists were sorted by price, this is the cheapest configuration for this RAM.
                // Stop checking other mobos for this same RAM to save speed.
                if (OPTIMIZE_BUILD_RESULTS) break; 
            }
        }
    }

function deduplicateBuilds() {
    if (!sqlDB) return;
    
    console.log("Removing duplicate builds...");
    
    sqlDB.run(`
        DELETE FROM builds 
        WHERE id NOT IN (
            SELECT MIN(id) 
            FROM (
                SELECT id, score,
                    cpuName, gpuName, gpuCnt, ramName, ramSticks,
                    moboName, caseName, coolerName, psuName, fanName, storageNames,
                    MAX(score) OVER (
                        PARTITION BY cpuName, gpuName, gpuCnt, ramName, ramSticks,
                                     moboName, caseName, coolerName, psuName, fanName, storageNames
                    ) as bestScore
                FROM builds
            )
            WHERE score = bestScore
            GROUP BY cpuName, gpuName, gpuCnt, ramName, ramSticks,
                     moboName, caseName, coolerName, psuName, fanName, storageNames
        )
    `);
    
    const removed = sqlDB.exec("SELECT changes()")[0].values[0][0];
    console.log(`Removed ${removed} duplicate builds`);
}



    function finishScan(config) {

    deduplicateBuilds(); // ADD THIS LINE
    
    const btn = document.getElementById('generateBtn');
        btn.disabled = false;
        btn.innerText = "GENERATE BUILDS";

        const total = getTotalBuilds();
        const { min, max } = getScoreRange();
        
        document.getElementById('resCount').innerText = `${formatNumber(total)} Builds Found`;
        document.getElementById('scanStatus').innerText = "Scan Complete.";
        
        const scoreRangeDisplay = document.getElementById('scoreRangeDisplay');
        scoreRangeDisplay.innerText = `Lowest: ${formatNumber(min)} | Highest: ${formatNumber(max)}`;
        
        document.getElementById('pagination').style.display = total > 0 ? 'flex' : 'none';
        
        renderPage(1);
    }

    function renderPage(page, forceRefresh = false) {
    currentPage = page;
    const sort = document.getElementById('mainSort').value;
    const total = getTotalBuilds();

    if (total === 0) {
        document.getElementById('resultsList').innerHTML = '<div style="text-align:center;padding:40px;color:#e74c3c;font-size:1.4em;">No Builds Found</div>';
        return;
    }

    const start = (page - 1) * itemsPerPage;
    
    // FIX: Only fetch from SQL if we aren't forcing a local refresh
    if (!forceRefresh) {
        builds = getBuildsFromSQL(sort, itemsPerPage, start);
    }
    
    const totalPages = Math.ceil(total / itemsPerPage);
    const useOC = globalUseOC;

    const list = document.getElementById('resultsList');
    list.innerHTML = '';

    builds.forEach((b, i) => {
        const diffClass = b.diff > 0 ? 'diff-pos' : 'diff-neg';
        const sign = b.diff > 0 ? '+' : '';
        const gpuClass = getBrandClass(b.gpu);
        const cpuClass = getBrandClass(b.cpu);
        const buildIdx = i; // Index relative to current page

        const gpuCountStr = b.gpuCnt > 1 ? `${b.gpuCnt}x ` : '';
        const gpuEmoji = b.gpu.isWater ? 'ðŸ’§' : 'ðŸ’¨';
        
        const gpuSpecs = `
            Score: ${formatNumber(b.gpuScore)} | ${b.gpu.vram}GB | ${b.gpu.length}mm | ${b.gpu.watts * b.gpuCnt}W | ${gpuEmoji} | 
            Base Core/Max Core: ${b.gpu.baseCore || '?'}/${b.gpu.maxCore || '?'} MHz | 
            Base Mem/Max Mem: ${b.gpu.baseMem || '?'}/${b.gpu.maxMem || '?'} MHz
        `;
        
        const displayCpuScore = b.liveCpuScore;
        let cpuSpecs = "";

        if (currentMode === 'TSX') {
            cpuSpecs = `
                Base Score (TSX): ${formatNumber(displayCpuScore)} | ${b.cpu.socket} | ${b.cpu.cores} Cores | 
                ${b.cpu.baseFreq || '?'} / ${b.cpu.maxFreq || '?'} MHz | 
                ${b.cpu.voltage || '?'}/${b.cpu.maxVoltage || '?'} V
            `;
        } else if (useOC) {
            cpuSpecs = `
                OC Score: ${formatNumber(displayCpuScore)} | ${b.cpu.socket} | ${b.cpu.cores} Cores | 
                ${b.cpu.baseFreq || '?'} / ${b.cpu.maxFreq || '?'} MHz | 
                ${b.cpu.voltage || '?'}/${b.cpu.maxVoltage || '?'} V
            `;
        } else {
            cpuSpecs = `
                Base Score: ${formatNumber(displayCpuScore)} | ${b.cpu.socket} | ${b.cpu.cores} Cores | 
                ${b.cpu.baseFreq || '?'} / ${b.cpu.maxFreq || '?'} MHz | 
                ${b.cpu.voltage || '?'}/${b.cpu.maxVoltage || '?'} V
            `;
        }

        let ramHTML = '';
        if (b.ram) {
            ramHTML = renderInteractive('RAM', 
                b.ram, 
                buildIdx, 
                'ram', 
                `${b.ramSticks}x | ${b.ram.freq} MHz | ${b.ram.type} | Size Each: ${b.ram.size}GB | Total: ${b.ram.size * b.ramSticks}GB`,
                'brand-ram'
            );
        }

        let auxHTML = '';
        if (b.mobo) {
            auxHTML += renderInteractive('Motherboard',
                b.mobo,
                buildIdx,
                'mobo',
                `${b.mobo.socket} | ${b.mobo.ramType} | ${b.mobo.size} Form Factor | PCI Slots: ${b.mobo.pciSlots}`,
                'brand-aux'
            );
        }

        if (b.psu) {
            auxHTML += renderInteractive('PSU',
                b.psu,
                buildIdx,
                'psu',
                `${b.psu.watts}W | Length: ${b.psu.length}mm`,
                'brand-aux'
            );
        }

        let interactiveHTML = '';
        
        if (b.storages && b.storages.length > 0) {
            let totalStoragePrice = b.storages.reduce((acc, s) => acc + s.price, 0);
            const storageCounts = {};
            b.storages.forEach(s => {
                if (!storageCounts[s.name]) storageCounts[s.name] = { count: 0, part: s };
                storageCounts[s.name].count++;
            });

            let summaryParts = [];
            Object.values(storageCounts).forEach(item => {
                const s = item.part;
                const c = item.count;
                summaryParts.push(`${c}x ${s.sizeStr} ${s.type}`);
            });

            interactiveHTML += renderInteractive('Storage', 
                { name: "Manage Storage", price: totalStoragePrice }, 
                buildIdx, 'storage', summaryParts.join(" | ")
            );
        } else if (document.getElementById('incStorage').checked) {
                interactiveHTML += renderInteractive('Storage', {name: "Add Storage", price: 0}, buildIdx, 'storage', "No drives selected");
        }

        if (b.case) {
            interactiveHTML += renderInteractive('Case', b.case, buildIdx, 'cases',
                `Max GPU: ${b.case.maxGpuLen}mm | CPU H: ${b.case.maxCpuHeight}mm | Size: ${b.case.size} | GPU Slots: ${b.case.gpuSlots} | SSD: ${b.case.ssdSlots} | HDD: ${b.case.hddSlots}`
            );
        }
        if (b.cooler) {
            interactiveHTML += renderInteractive('Cooler', b.cooler, buildIdx, 'cooler',
                `${b.cooler.type} | ${b.cooler.type.includes('Air') ? `Height: ${b.cooler.height}mm` : `Size: ${b.cooler.size}mm`} | Flow: ${b.cooler.flow} CFM`
            );
        }
        if (b.fan) {
            interactiveHTML += renderInteractive('Case Fans (x1)', b.fan, buildIdx, 'fan',
                `Size: ${b.fan.size}mm | Airflow: ${b.fan.flow} CFM`
            );
        }

        const html = `
        <div class="build-card" style="animation-delay:${forceRefresh ? '0s' : i*0.02 + 's'}">
            <div class="card-header">
                <div class="score-container">
                    <span class="build-number">#${start + i + 1}</span>
                    <div class="score-box">${formatNumber(b.score)}</div>
                    <div class="diff-box ${diffClass}">${sign}${Math.abs(Math.round(b.diff))}</div>
                </div>
                <div class="header-stats">
                    <div class="stats-row">
                        <div class="watts-box">âš¡ ${b.watts}W</div>
                        <div class="price-box">${formatCurrency(b.price)}</div>
                    </div>
                    <div class="level-box">GPU L${b.gpu.level} | CPU L${b.cpu.level}</div>
                </div>
                </div>
            </div>
            <div class="card-body">
                <div class="part-row ${gpuClass} text-colored">
                    <div class="part-header">
                        <span class="part-label" style="font-size: 1.5em; font-weight: 900;">${gpuCountStr}GPU</span>
                        <span class="part-price">${formatCurrency(b.gpu.price * b.gpuCnt)}</span>
                    </div>
                    <div class="part-name">${b.gpu.name}</div>
                    <div class="part-specs">${gpuSpecs}</div>
                </div>
                <div class="part-row ${cpuClass} text-colored">
                    <div class="part-header">
                        <span class="part-label">CPU</span>
                        <span class="part-price">${formatCurrency(b.cpu.price)}</span>
                    </div>
                    <div class="part-name">${b.cpu.name}</div>
                    <div class="part-specs">${cpuSpecs}</div>
                </div>
                ${ramHTML}
                ${auxHTML}
                ${interactiveHTML}
            </div>
        </div>`;
        list.innerHTML += html;
    });

    const pageInfo = document.getElementById('pageInfo');
    if (!pageInfo.querySelector('input')) {
        pageInfo.innerText = `Page ${page} of ${totalPages}`;
    }
    document.getElementById('btnPrev').disabled = (page === 1);
    document.getElementById('btnNext').disabled = (page === totalPages || totalPages === 0);
}

function renderInteractive(label, part, bIdx, type, specs, colorClass = 'brand-generic') {
    const build = builds[bIdx];
    let price = part.price;
    let revertBtn = '';

    // Check if we need a Revert Button
    let isChanged = false;

    // FIX: Normalize the key name to match the build object structure
    // The build object uses 'case' (singular), but the category type is 'cases' (plural)
    const buildKey = type === 'cases' ? 'case' : type;

    if (type === 'storage') {
        // Complex check for storage arrays
        const origNames = build.original.storages.map(s => s.name).sort().join(',');
        const currNames = build.storages.map(s => s.name).sort().join(',');
        if (origNames !== currNames) isChanged = true;
    } else {
        // Simple name check for single parts using the corrected buildKey
        if (build.original[buildKey] && build.original[buildKey].name !== part.name) {
            isChanged = true;
        } else if (!build.original[buildKey] && part) {
            // Part was added where there was none
            isChanged = true;
        } 
        // --- FIX IS HERE ---
        // Change 'build.originalSticks' to 'build.original.ramSticks'
        else if (type === 'ram' && build.ramSticks !== build.original.ramSticks) {
            // Special check for RAM quantity changes
            isChanged = true;
        }
    }

    if (isChanged) {
        // We pass 'type' to revertPart because the rest of the system uses the category strings
        revertBtn = `<button class="btn-revert" onclick="revertPart(${bIdx}, '${type}', event)" title="Revert to original">â†º</button>`;
    }

    return `
    <div class="part-row interactive ${colorClass} text-colored" onclick="openSwapPopup('${type}', ${bIdx})">
        ${revertBtn}
        <button class="btn-change">${type === 'storage' ? 'Manage' : 'Change'}</button>
        <div class="part-header">
            <span class="part-label">${label}</span>
            <span class="part-price">${formatCurrency(price)}</span>
        </div>
        <div class="part-name">${part.name}</div>
        <div class="part-specs">${specs}</div>
    </div>`;
}

function revertPart(buildIdx, type, event) {
    if(event) event.stopPropagation(); 
    
    const build = builds[buildIdx];
    const buildKey = type === 'cases' ? 'case' : type;
    
    // 1. Restore Logic
    if (type === 'storage') {
        build.storages = [...build.original.storages]; 
    } else {
        const originalPart = build.original[buildKey];
        if (!originalPart && type !== 'fan') return; // Fan is optional, might not have original
        
        build[buildKey] = originalPart;

        // If restoring RAM, Restore Sticks count AND Recalc Scores
        if (type === 'ram') {
            // Restore original stick count
            if (build.original.ramSticks) {
                build.ramSticks = build.original.ramSticks; // Assumes you save this during generation (see below)
            } else {
                // Fallback if not saved in original object
                build.ramSticks = parseInt(document.getElementById('ramSticks').value) || 1; 
                // Note: To make this perfect, you should add ramSticks to build.original in getBuildsFromSQL
            }

             const newCpuScore = calculateCpuScore(
                build.cpu, originalPart, build.ramSticks,
                currentMode, globalUseOC, globalUseXMP
            );
            build.liveCpuScore = newCpuScore;
            build.score = calculate3DMark(newCpuScore, build.gpuScore);
            
            const targetScore = parseInt(document.getElementById('targetScore').value.replace(/,/g, '')) || 20000;
            build.diff = build.score - targetScore;
        }
    }

    // 2. Recalculate Total Price
    let newPrice = build.cpu.price + (build.gpu.price * build.gpuCnt);
    if (build.ram) newPrice += (build.ram.price * build.ramSticks);
    if (build.mobo) newPrice += build.mobo.price;
    if (build.case) newPrice += build.case.price;
    if (build.cooler) newPrice += build.cooler.price;
    if (build.psu) newPrice += build.psu.price;
    if (build.fan) newPrice += build.fan.price;
    if (build.storages) build.storages.forEach(s => newPrice += s.price);
    
    build.price = newPrice;

    // 3. Render
    renderPage(currentPage, true);
}
    function changePage(d) {
        const total = getTotalBuilds();
        const totalPages = Math.ceil(total / itemsPerPage);
        const n = currentPage + d;
        if (n > 0 && n <= totalPages) renderPage(n);
    }

    function makePageEditable() {
        const pageInfo = document.getElementById('pageInfo');
        if (pageInfo.querySelector('input')) return;
        const total = getTotalBuilds();
        const totalPages = Math.ceil(total / itemsPerPage);
        const input = document.createElement('input');
        input.type = 'number';
        input.value = currentPage;
        input.className = 'page-jump-input';
        const save = () => {
            let val = parseInt(input.value);
            if (isNaN(val) || val < 1) val = 1;
            if (val > totalPages) val = totalPages;
            pageInfo.innerHTML = '';
            renderPage(val);
        };
        input.onblur = save;
        input.onkeydown = (e) => { if (e.key === 'Enter') input.blur(); };
        pageInfo.innerHTML = '';
        pageInfo.appendChild(input);
        input.focus();
        input.select();
    }

    function openSwapPopup(type, buildIdx) {
    const build = builds[buildIdx];
    
    let original = null;
    if (type === 'fan') original = build.fan;
    else if (type === 'cases') original = build.case;
    else if (type === 'cooler') original = build.cooler;
    else if (type === 'mobo') original = build.mobo;          // NEW
    else if (type === 'ram') original = build.ram;            // NEW
    else if (type === 'psu') original = build.psu;            // NEW
    else if (type === 'storage') original = null; 

    currentPopupData = {
        type,
        buildIdx, 
        originalPart: original,
        originalSticks: type === 'ram' ? build.ramSticks : null  // NEW - Store RAM stick count
    };

    document.getElementById('popupSearch').value = "";
    document.getElementById('popupTitle').innerText = `Swap ${type.toUpperCase()}`;
    document.getElementById('popupOverlay').style.display = 'block';
    document.getElementById('popupContainer').style.display = 'flex';
    refreshPopup();
}

    function closePopup() {
        document.getElementById('popupOverlay').style.display = 'none';
        document.getElementById('popupContainer').style.display = 'none';
        currentPopupData = null;
    }

    function refreshPopup() {
    // 1. Safety Checks
    if (!currentPopupData) return;
    const { type, buildIdx } = currentPopupData;
    const build = builds[buildIdx];
    
    // 2. Get Filter Inputs
    const fitOnly = document.getElementById('popupFit').checked;
    const sortMode = document.getElementById('popupSort').value;
    const searchVal = document.getElementById('popupSearch').value.toLowerCase();
    
    const tbody = document.getElementById('popupTableBody');
    tbody.innerHTML = '';

    // 3. Get Candidates from Database
    let candidates = Array.from(DB[type].values());

    // 4. Apply Filters
    if (fitOnly) {
        candidates = candidates.filter(part => checkFit(type, part, build));
    }

    if (searchVal) {
        candidates = candidates.filter(part => part.name.toLowerCase().includes(searchVal));
    }

    // 5. Apply Sorting
    candidates.sort((a,b) => {
        if (sortMode === 'price_asc') return a.price - b.price;
        if (sortMode === 'price_desc') return b.price - a.price;
        
        let valA = 0;
        let valB = 0;
        
        // Define "Performance" metric based on type
        if (type === 'cases') { valA = a.maxGpuLen; valB = b.maxGpuLen; } 
        else if (type === 'cooler' || type === 'fan') { valA = a.flow || 0; valB = b.flow || 0; }
        else if (type === 'storage') { valA = a.speed || 0; valB = b.speed || 0; }
        else if (type === 'ram') { valA = a.freq || 0; valB = b.freq || 0; }
        else if (type === 'psu') { valA = a.watts || 0; valB = b.watts || 0; }
        
        if (sortMode === 'perf_desc') return valB - valA;

        // Value Sorting (Performance / Price)
        let scoreA = (valA / (a.price || 1));
        let scoreB = (valB / (b.price || 1));
        
        if (sortMode === 'val_desc') return scoreB - scoreA; 
        if (sortMode === 'val_asc') return scoreA - scoreB; 
        
        return 0;
    });

    // 6. Identification logic
    // Handle Singular keys vs Plural types (case vs cases)
    const buildKey = type === 'cases' ? 'case' : type;
    const currentPartName = (type !== 'storage' && build[buildKey]) ? build[buildKey].name : null;
    const originalPartName = (type !== 'storage' && build.original && build.original[buildKey]) ? build.original[buildKey].name : null;

    // 7. Render Loop (Limit to 100 to prevent lag)
    const subset = candidates.slice(0, 100);

    subset.forEach((p, idx) => {
        let currentPrice = 0;
        if (type === 'storage') currentPrice = 0; 
        else if (type === 'ram') currentPrice = build.ram ? build.ram.price : 0; // Per stick price for diff
        else if (build[buildKey]) currentPrice = build[buildKey].price;

        let newPrice = p.price;
        let actionBtn = "";
        let diffStr = "";
        let diffClass = "";

        const safeName = p.name.replace(/'/g, "\\'");

        // --- BRANCH A: STORAGE LOGIC ---
        if (type === 'storage') {
            const currentDrives = build.storages || [];
            const isSelected = currentDrives.some(d => d.name === p.name);
            const count = currentDrives.filter(d => d.name === p.name).length;
            
            const isSSD = (p.type === 'SSD' || p.type === 'M.2');
            const slotCount = isSSD ? build.case.ssdSlots : build.case.hddSlots;
            const currentSameType = currentDrives.filter(d => (d.type === 'SSD' || d.type === 'M.2') === isSSD);
            const slotsFull = currentSameType.length >= slotCount;

            if (isSelected) {
                let addBtn = !slotsFull 
                    ? `<button class="btn-select-part" style="padding: 8px 12px; margin-left:5px;" onclick="toggleStorage('${safeName}', 1)">+</button>` 
                    : '';
                
                actionBtn = `
                    <div style="display:flex; align-items:center;">
                        <button class="btn-select-part is-current" onclick="toggleStorage('${safeName}', -1)">REMOVE (${count})</button>
                        ${addBtn}
                    </div>
                `;
            } else if (slotsFull) {
                actionBtn = `<button class="btn-select-part" disabled style="background:#444; color:#888;">FULL</button>`;
            } else {
                actionBtn = `<button class="btn-select-part" onclick="toggleStorage('${safeName}', 1)">ADD</button>`;
            }
            diffStr = formatCurrency(p.price);
        } 
        // --- BRANCH B: RAM LOGIC (NEW MULTI-ADD) ---
        else if (type === 'ram') {
            // Is this the currently selected RAM model?
            const isCurrentModel = (p.name === currentPartName);
            const count = isCurrentModel ? build.ramSticks : 0;
            
            // Limit check (Mobo slots)
            const maxSlots = (build.mobo && build.mobo.size === 'Mini-ITX') ? 2 : 4;
            const isFull = (count >= maxSlots);

            if (isCurrentModel) {
                 let addBtn = !isFull 
                    ? `<button class="btn-select-part" style="padding: 8px 12px; margin-left:5px;" onclick="toggleRam('${safeName}', 1)">+</button>` 
                    : `<button class="btn-select-part" disabled style="padding: 8px 12px; margin-left:5px; background:#555;">Max</button>`;
                
                actionBtn = `
                    <div style="display:flex; align-items:center;">
                        <button class="btn-select-part is-current" onclick="toggleRam('${safeName}', -1)">-</button>
                        <span style="font-weight:bold; margin:0 10px; font-size:1.2em;">${count}</span>
                        ${addBtn}
                    </div>
                `;
            } else {
                // If selecting a NEW RAM, start with 1 stick (or keep current count? Let's start with 1 to be safe/clear)
                actionBtn = `<button class="btn-select-part" onclick="toggleRam('${safeName}', 1, true)">SELECT</button>`;
            }

            // Price diff per stick
            const diff = newPrice - currentPrice;
            diffStr = diff > 0 ? `+${formatCurrency(diff)}` : (diff < 0 ? `-${formatCurrency(Math.abs(diff))}` : '$0.00');
            diffStr += " / stick"; // Clarify it's unit price
            diffClass = diff > 0 ? 'val-neg' : (diff < 0 ? 'val-pos' : '');
        }
        // --- BRANCH C: STANDARD PART LOGIC ---
        else {
            const diff = newPrice - currentPrice;
            diffStr = diff > 0 ? `+${formatCurrency(diff)}` : (diff < 0 ? `-${formatCurrency(Math.abs(diff))}` : '$0.00');
            diffClass = diff > 0 ? 'val-neg' : (diff < 0 ? 'val-pos' : '');

            if (p.name === currentPartName) {
                if (p.name !== originalPartName) {
                    actionBtn = `<button class="btn-select-part is-current" onclick="revertPart(${buildIdx}, '${type}'); closePopup();">CURRENT (REVERT)</button>`;
                } else {
                    actionBtn = `<button class="btn-select-part selected">SELECTED</button>`;
                }
            } else if (p.name === originalPartName) {
                actionBtn = `<button class="btn-select-part revert-target" onclick="revertPart(${buildIdx}, '${type}'); closePopup();">REVERT TO THIS</button>`;
            } else {
                actionBtn = `<button class="btn-select-part" onclick="selectReplacementPart('${safeName}')">SELECT</button>`;
            }
        }

        let details = '';
        if (type === 'cases') details = `Max GPU: ${p.maxGpuLen}mm | Size: ${p.size} | GPU Slots: ${p.gpuSlots}`;
        else if (type === 'cooler') details = `${p.type} | Flow: ${p.flow}`;
        else if (type === 'fan') details = `Size: ${p.size}mm | Flow: ${p.flow} CFM`;
        else if (type === 'storage') details = `${p.sizeStr} | ${p.type} | Level ${p.level} | ${p.speed} MB/s`;
        else if (type === 'ram') details = `${p.freq} MHz | ${p.type} | ${p.size}GB | ${p.mfgr}`;
        else if (type === 'mobo') details = `${p.socket} | ${p.size} | ${p.ramType}`;
        else if (type === 'psu') details = `${p.watts}W | ${p.length}mm`;

        const tr = document.createElement('tr');
        tr.innerHTML = `
            <td style="width:180px;">${actionBtn}</td>
            <td style="font-weight:bold; color:#fff;">${p.name}</td>
            <td style="font-size:0.9em; color:#aaa;">${details}</td>
            <td class="price-red-cell">${formatCurrency(newPrice)}</td>
            <td class="${diffClass}">${diffStr}</td>
        `;
        tbody.appendChild(tr);
    });
}


window.toggleRam = function(partName, delta, isNewSelection = false) {
    if (!currentPopupData || currentPopupData.type !== 'ram') return;
    
    const newPart = DB['ram'].get(partName);
    const build = builds[currentPopupData.buildIdx];
    if (!newPart) return;

    let newCount = build.ramSticks;

    if (isNewSelection) {
        // Switching to a completely new RAM model
        build.ram = newPart;
        // Default to 1 stick when switching, or keep existing count? 
        // Let's default to 1 to ensure validity, user can add more.
        newCount = 1; 
    } else {
        // Adjusting count of current RAM
        newCount += delta;
    }

    // Bounds Check
    const maxSlots = (build.mobo && build.mobo.size === 'Mini-ITX') ? 2 : 4;
    if (newCount > maxSlots) newCount = maxSlots;
    if (newCount < 1) newCount = 1; // Minimum 1 stick

    // Apply Count
    build.ramSticks = newCount;

    // Recalculate Scores (Changing sticks/model affects Dual/Quad Channel score)
    const newCpuScore = calculateCpuScore(
        build.cpu, build.ram, build.ramSticks,
        currentMode, globalUseOC, globalUseXMP
    );
    build.liveCpuScore = newCpuScore;
    build.score = calculate3DMark(newCpuScore, build.gpuScore);
    
    // Update Diff
    const targetScore = parseInt(document.getElementById('targetScore').value.replace(/,/g, '')) || 20000;
    build.diff = build.score - targetScore;

    // Recalculate Price
    // Price = Core Parts + RAM + Storage + Case/Mobo/etc
    // Easiest way is to recalculate total from scratch to be safe
    let newTotal = 0;
    newTotal += build.cpu.price;
    newTotal += (build.gpu.price * build.gpuCnt);
    newTotal += (build.ram.price * build.ramSticks);
    if(build.mobo) newTotal += build.mobo.price;
    if(build.case) newTotal += build.case.price;
    if(build.cooler) newTotal += build.cooler.price;
    if(build.psu) newTotal += build.psu.price;
    if(build.fan) newTotal += build.fan.price;
    if(build.storages) build.storages.forEach(s => newTotal += s.price);

    build.price = newTotal;

    // Refresh UI
    refreshPopup();
    renderPage(currentPage, true);
}

    window.toggleStorage = function(partName, delta) {
    if (!currentPopupData || currentPopupData.type !== 'storage') return;
    const newPart = DB['storage'].get(partName);
    const build = builds[currentPopupData.buildIdx];

    if (delta > 0) {
        build.storages.push(newPart);
        build.price += newPart.price;
    } else {
        const existsIdx = build.storages.findIndex(d => d.name === partName);
        if (existsIdx > -1) {
            build.storages.splice(existsIdx, 1);
            build.price -= newPart.price;
        }
    }
    refreshPopup();
    
    // FIX: Pass 'true' to keep storage changes
    renderPage(currentPage, true);
}

    window.selectReplacementPart = function(partName) {
    if (!currentPopupData) return;
    const newPart = DB[currentPopupData.type].get(partName);
    if(!newPart) return;

    const { type, buildIdx, originalPart } = currentPopupData;
    const build = builds[buildIdx];

    // 1. Calculate Price Difference
    let priceDiff = 0;
    
    if (type === 'ram') {
        const count = build.ramSticks || 1;
        const oldPriceTotal = originalPart ? (originalPart.price * count) : 0;
        const newPriceTotal = newPart.price * count;
        priceDiff = newPriceTotal - oldPriceTotal;
    } else {
        priceDiff = newPart.price - (originalPart ? originalPart.price : 0);
    }
    
    // 2. Assign the new part
    if (type === 'cases') build.case = newPart;
    else if (type === 'cooler') build.cooler = newPart;
    else if (type === 'fan') build.fan = newPart;
    else if (type === 'mobo') build.mobo = newPart;
    else if (type === 'psu') build.psu = newPart;
    else if (type === 'ram') {
        build.ram = newPart;

        // Recalculate Scores for RAM
        const newCpuScore = calculateCpuScore(
            build.cpu, newPart, build.ramSticks,
            currentMode, globalUseOC, globalUseXMP
        );
        build.liveCpuScore = newCpuScore;
        build.score = calculate3DMark(newCpuScore, build.gpuScore);
        
        const targetScore = parseInt(document.getElementById('targetScore').value.replace(/,/g, '')) || 20000;
        build.diff = build.score - targetScore;
    }

    // 3. Update Build Price
    build.price += priceDiff;

    closePopup();
    
    // FIX: Pass 'true' to keep the changes we just made in memory
    renderPage(currentPage, true); 
}

    function checkFit(type, part, build) {
        const lvl = parseInt(document.getElementById('level').value);
        if (part.level > lvl) return false;

        if (type === 'cases') {
            if (part.maxGpuLen < build.gpu.length) return false;
            if (build.mobo && !part.moboSizes.includes(build.mobo.size)) return false;
            if (build.cooler && build.cooler.type.includes('Air') &&
                part.maxCpuHeight < build.cooler.height) return false;
            if (build.psu && part.maxPsuLen > 0 && build.psu.length > part.maxPsuLen) return false;
            if (build.gpuCnt > 1 && part.gpuSlots < 3) return false;
            if (build.storages) {
                const ssds = build.storages.filter(s => s.type==='SSD' || s.type==='M.2').length;
                const hdds = build.storages.filter(s => s.type==='HDD').length;
                if (ssds > part.ssdSlots) return false;
                if (hdds > part.hddSlots) return false;
            }
            return true;
        }

        if (type === 'cooler') {
            if (!part.sockets.includes(build.cpu.socket)) return false;
            if (build.case) {
                if (part.type.includes('Air')) return build.case.maxCpuHeight >= part.height;
                if (part.type.includes('Liquid')) return build.case.radSizes.includes(part.size.toString());
            }
            return true;
        }

if (type === 'fan') {
            if (!build.case) return true;
            const s120 = build.case.radSizes.includes('120');
            const s140 = build.case.radSizes.includes('140');
            if (part.size === 120 && !s120) return false;
            if (part.size === 140 && !s140) return false;
            return true;
        }

        // NEW: Motherboard compatibility checks
        if (type === 'mobo') {
            if (part.socket !== build.cpu.socket) return false;
            if (build.ram && part.ramType !== build.ram.type) return false;
            if (build.gpuCnt > 1 && part.pciSlots < 5) return false;
            if (build.gpuCnt > 1) {
                const sliType = build.gpu.sliType;
                if (sliType === 'SLI' && !part.supportSLI) return false;
                if (sliType === 'Crossfire' && !part.supportCF) return false;
            }
            if (build.case && !build.case.moboSizes.includes(part.size)) return false;
            if (build.ramSticks === 4 && part.size === 'Mini-ITX') return false;
            return true;
        }

        // NEW: RAM compatibility checks
        if (type === 'ram') {
            if (build.mobo && part.type !== build.mobo.ramType) return false;
            if (!build.cpu.memTypes.includes(part.type)) return false;
            return true;
        }

        // NEW: PSU compatibility checks
        if (type === 'psu') {
            const totalWatts = build.watts; // Build already has total watts calculated
            if (part.watts < totalWatts) return false;
            if (build.case && build.case.maxPsuLen > 0 && part.length > build.case.maxPsuLen) return false;
            return true;
        }

        return true;
    }

</script>
</body>
</html>
